# OAuth2 Authentication in MCP with A2A Protocol Forwarding — Specification Document

> Generated on: 2026-02-22
> Version: 1.0
> Status: Draft

## 1. Executive Summary

This specification defines how OAuth2 Bearer tokens are propagated through the full agent platform chain (Web UI -> Agent API -> A2A agents -> MCP servers) and how the web UI implements an on-demand OAuth2 authorization code flow to obtain tokens when MCP servers require authentication.

Today, the platform forwards Bearer tokens through A2A calls but **not** to MCP servers — the MCP HTTP client discards the caller's context and creates a bare `context.Background()`. This spec fixes that gap and adds a lazy OAuth2 flow in the web UI: users chat without logging in, and authentication is triggered only when an MCP tool (or an A2A sub-agent's MCP tool) returns HTTP 401.

The test endpoint is `https://contacts.mcp.scm-platform.org`, a Google Contacts MCP server that expects a valid Google OAuth2 Bearer token.

## 2. Scope

### 2.1 In Scope

- Thread `context.Context` through the `mcp.Client` interface so Bearer tokens reach MCP servers via HTTP headers
- Add `auth-required` task state to the A2A protocol types (standard A2A spec RC v1.0)
- Agent detects HTTP 401 from MCP servers and returns `auth_required` in REST API responses / `auth-required` in A2A task state
- Propagate `auth-required` through the full A2A chain (Agent-B -> Agent-A -> Web UI)
- Web UI implements OAuth2 authorization code flow with Google as the provider
- Web UI stores OAuth2 tokens server-side in SQLite with automatic refresh
- Web UI session management with persistent cookies (30-day `Max-Age`)
- Web UI auto-retries the failed message after OAuth2 flow completes
- Logout with token revocation at Google
- Infinite auth loop detection (max 1 retry per message)

### 2.2 Out of Scope (Non-Goals)

- CLI client OAuth2 flow (no CLI exists yet)
- MCP server-side OAuth2 management (MCP servers just validate Bearer tokens)
- Scope enforcement in the platform (MCP servers reject invalid tokens themselves)
- Multi-provider OAuth2 support (Google only for now)
- Per-MCP-server token routing (single token forwarded to all MCP servers)
- Client credentials flow (only authorization code flow)
- Token encryption at rest (plaintext in SQLite, consistent with existing patterns)

## 3. User Personas & Actors

**Web User:** A person using the web chat UI (`cmd/web`) to interact with agents. May or may not have a Google account. Does not need to authenticate to use the chat — authentication is triggered on-demand when an MCP tool requires it.

**Agent Platform:** The agent API (`cmd/agent`) and its internal components (LLM client, MCP client, A2A client). Acts as a transparent token pipe — accepts Bearer tokens from callers and forwards them to MCP servers and A2A agents.

**MCP Server:** An external MCP server (e.g., `https://contacts.mcp.scm-platform.org`) that expects a valid OAuth2 Bearer token. Returns HTTP 401 when no valid token is provided.

## 4. Usage Scenarios

### SC-001: On-Demand OAuth2 Flow

**Actor:** Web User
**Preconditions:** No valid session exists in the web server's SQLite database. An MCP server requires OAuth2 authentication.
**Flow:**
1. User sends a chat message (e.g., "Search my contacts for John").
2. Web server proxies the request to the agent API without a Bearer token (no session exists).
3. Agent's LLM selects an MCP tool on the contacts server.
4. Agent calls the MCP server via the HTTP client without a Bearer token.
5. MCP server returns HTTP 401 Unauthorized.
6. Agent detects the 401 and returns a response with `auth_required: true` to the web UI.
7. Web UI receives `auth_required`, stores the pending message in the browser's `sessionStorage`.
8. Web UI redirects the user to Google's authorization URL with client ID, redirect URI, scopes, and a CSRF state parameter.
9. User logs in to Google (if not already) and consents to the requested scopes.
10. Google redirects back to the web UI callback (`GET /callback?code=...&state=...`).
11. Web server validates the CSRF state parameter.
12. Web server exchanges the authorization code for access token + refresh token via Google's token URL.
13. Web server creates a session in SQLite, storing the tokens and expiry timestamp.
14. Web server sets a persistent session cookie (`asg_session`, `HttpOnly`, `SameSite=Lax`, `Max-Age=30d`).
15. Web server redirects the user back to the chat page.
16. Web UI detects the pending message in `sessionStorage`, automatically retries the original request.
17. Web server reads the session, injects the Bearer token into the proxied request.
18. Agent forwards the token to the MCP server, tool call succeeds.
19. Result is displayed to the user.
**Postconditions:** User has a valid session with OAuth2 tokens. The original message has been processed successfully.
**Exceptions:**
- EXC-001a: Authorization code exchange fails (code expired, CSRF mismatch) -> Show error page with "Try again" link that restarts the OAuth2 flow.
- EXC-001b: Google OAuth2 service is down -> Show error message, user can retry later.
- EXC-001c: Infinite auth loop — OAuth2 completes but MCP server still returns 401 (wrong scopes, wrong account) -> Detect consecutive auth-required for the same message (max 1 retry), show error: "Authentication failed. The MCP server rejected your credentials."

### SC-002: Authenticated MCP Tool Call (Happy Path)

**Actor:** Web User
**Preconditions:** User has a valid session with an active (non-expired) OAuth2 access token in SQLite.
**Flow:**
1. User sends a chat message.
2. Web server reads the session, extracts the access token, injects `Authorization: Bearer <token>` into the proxied request to the agent API.
3. Agent receives the Bearer token, stores it in context via `extractContext()`.
4. Agent's LLM selects an MCP tool.
5. Agent calls the MCP HTTP client, which forwards the Bearer token from context to the MCP server.
6. MCP server validates the token, executes the API call, returns the result.
7. Result flows back: MCP server -> Agent -> Web UI -> Browser.
**Postconditions:** Tool executed successfully with the user's OAuth2 token. Session unchanged.
**Exceptions:**
- EXC-002a: MCP server returns 401 despite valid session (token revoked externally) -> Web server attempts token refresh. If refresh succeeds, retry. If refresh fails, clear session and trigger SC-001.
**Cross-scenario notes:** The A2A variant follows the same flow: Agent-A receives the token, forwards it via A2A headers to Agent-B, which forwards it to the MCP server. Bearer token forwarding through A2A already works today.

### SC-003: Token Auto-Refresh

**Actor:** Web User
**Preconditions:** User has a valid session. Access token has expired (`expires_at` is in the past). Refresh token is valid.
**Flow:**
1. User sends a chat message.
2. Web server reads the session, detects the access token is expired.
3. Web server uses the refresh token to request a new access token from Google's token URL.
4. Google returns a new access token (and possibly a new refresh token).
5. Web server updates the session in SQLite with the new tokens and expiry.
6. Web server injects the fresh access token into the proxied request.
7. Request proceeds normally (SC-002 flow).
**Postconditions:** Session updated with new tokens. Request processed successfully.
**Exceptions:**
- EXC-003a: Refresh token revoked or expired (user revoked app access in Google account) -> Google's token endpoint returns an error. Web server clears the invalid session. Request proceeds without a Bearer token. If the MCP tool needs auth, SC-001 kicks in.

### SC-004: User Logs Out

**Actor:** Web User
**Preconditions:** User has a valid session.
**Flow:**
1. User clicks the "Logout" button in the web UI.
2. Web UI sends `POST /logout` to the web server.
3. Web server reads the session, extracts the access token.
4. Web server calls Google's token revocation endpoint (`https://oauth2.googleapis.com/revoke`) with the token.
5. Web server deletes the session from SQLite.
6. Web server clears the session cookie on the browser.
7. Web server redirects the user to the chat page.
8. User can continue chatting without auth. Non-auth tools work normally.
**Postconditions:** Session deleted. Token revoked at Google. Cookie cleared. User is unauthenticated.
**Exceptions:**
- EXC-004a: Google revocation endpoint fails (network error, Google down) -> Log the failure as a warning, proceed with local session deletion anyway. Token will expire naturally.

### SC-005: Unauthenticated Usage

**Actor:** Web User
**Preconditions:** No session cookie exists.
**Flow:**
1. User visits the web UI at the root URL.
2. No session cookie is found — no login is required.
3. User chats normally with the agent.
4. Agent answers general questions, uses MCP tools that do not require auth (e.g., `resources_list`), delegates to A2A agents for non-auth tasks.
5. All requests are proxied without a Bearer token.
**Postconditions:** User interacts with the platform without authentication. No session created.
**Exceptions:**
- EXC-005a: User triggers an MCP tool that requires auth -> SC-001 kicks in (on-demand OAuth2 flow).

### SC-006: A2A Chain Auth-Required Propagation

**Actor:** Web User
**Preconditions:** No valid session. Agent-A delegates to Agent-B via A2A. Agent-B's MCP server requires authentication.
**Flow:**
1. User sends a message to Agent-A (no Bearer token in the request).
2. Agent-A's LLM decides to delegate to Agent-B via A2A.
3. Agent-A sends `message/send` to Agent-B without a Bearer token.
4. Agent-B's LLM picks an MCP tool on the contacts server.
5. Agent-B calls the MCP server without a token, gets HTTP 401.
6. Agent-B detects the 401 and returns a task with `state: "auth-required"` to Agent-A.
7. Agent-A receives the `auth-required` state from Agent-B.
8. Agent-A immediately propagates `auth_required: true` in its API response to the web UI.
9. Web UI receives `auth_required`, triggers the OAuth2 flow (SC-001, steps 7-16).
10. After authentication, web UI auto-retries the original message with the Bearer token.
11. Agent-A receives the token, delegates to Agent-B via A2A (token forwarded in headers).
12. Agent-B receives the token, calls the MCP server with it, tool call succeeds.
13. Result flows back through the full A2A chain.
**Postconditions:** User has a valid session. The full A2A chain re-executed with the token. Original message processed successfully.
**Exceptions:**
- EXC-006a: Infinite auth loop through A2A chain -> Same detection as EXC-001c (max 1 retry per message).
**Cross-scenario notes:** Unlike the approval proxy flow (`input-required`), no pending state is stored in Agent-A. The entire message is replayed from scratch after authentication.

## 5. Functional Requirements

### FR-001: Thread Context Through MCP Client Interface

- **Description:** The `mcp.Client` interface's `CallTool` method must accept a `context.Context` parameter so that Bearer tokens stored in the context are available to transport-level code.
- **Inputs:** `ctx context.Context`, `name string`, `args map[string]any`
- **Outputs:** `*CallToolResult`, `error`
- **Business Rules:**
  - The new signature is `CallTool(ctx context.Context, name string, args map[string]any) (*CallToolResult, error)`
  - All implementations must be updated: `HTTPClient`, `StdioClient`, `NopClient`, `CompositeClient`
  - All callers in `internal/agent/` must pass their context through
  - The context timeout for MCP HTTP calls (`httpClientTimeout = 30s`) must be applied on top of the passed context, not replace it
- **Priority:** Must-have

### FR-002: MCP HTTP Client Forwards Bearer Token

- **Description:** The `HTTPClient.CallTool` method must extract the Bearer token from the context and include it in HTTP requests to the MCP server.
- **Inputs:** Context containing a Bearer token (via `auth.BearerToken(ctx)`)
- **Outputs:** HTTP request to MCP server includes `Authorization: Bearer <token>` header
- **Business Rules:**
  - If no Bearer token is in the context, the request is sent without an `Authorization` header (backward compatible)
  - The token must also be forwarded during `Start()` / `connect()` / `loadToolsFrom()` if a context is available (but `Start()` currently uses `context.Background()` — this is acceptable since tool listing does not require auth)
  - The `mcp-go` library's transport layer must support custom headers or the client must inject them. If `mcp-go` does not support this natively, use a custom `http.RoundTripper` wrapper.
- **Priority:** Must-have

### FR-003: Agent Detects MCP 401 and Returns Auth-Required

- **Description:** When the MCP HTTP client receives an HTTP 401 from an MCP server, the agent must detect this error and return an `auth_required` signal instead of a generic error.
- **Inputs:** HTTP 401 response from MCP server during `CallTool`
- **Outputs:** `ProcessResult` with `AuthRequired: true` field set
- **Business Rules:**
  - The MCP HTTP client must surface 401 errors distinctly from other errors (e.g., a typed `AuthRequiredError` or a sentinel error)
  - The agent's `executeToolAndRespond` and related methods must check for this specific error type
  - When detected, the agent must not treat it as a tool execution failure — it must return a structured `auth_required` response
  - Log the 401 detection at `WARN` level
  - The conversation status must remain `active` (not `completed` or `failed`) so the retried message can proceed
- **Priority:** Must-have

### FR-004: Auth-Required in A2A Protocol

- **Description:** Add `auth-required` as a valid task state in the A2A protocol types, per the A2A specification RC v1.0.
- **Inputs:** Agent detects auth-required condition (from MCP 401 or from a sub-agent's `auth-required` task state)
- **Outputs:** A2A task response with `state: "auth-required"`
- **Business Rules:**
  - Add `"auth-required"` to the `TaskStatus.State` values in `internal/a2a/protocol.go`
  - When the agent acts as an A2A server and detects auth-required, the `a2aMessageSend` handler must return a task with `state: "auth-required"` instead of `state: "failed"`
  - When the agent acts as an A2A client and receives `state: "auth-required"` from a sub-agent, it must propagate the auth-required signal to its own caller (REST API response or upstream A2A response)
  - Propagation is immediate — no pending state is stored (unlike `input-required` for approvals)
- **Priority:** Must-have

### FR-005: REST API Auth-Required Response Field

- **Description:** The agent REST API must include an `auth_required` boolean field in `ProcessResult` responses when authentication is needed.
- **Inputs:** Agent's internal `ProcessResult` with `AuthRequired: true`
- **Outputs:** JSON response with `"auth_required": true` field
- **Business Rules:**
  - The `ProcessResult` struct gains a new field: `AuthRequired bool`
  - When `auth_required` is true, `response` must contain a human-readable message (e.g., "Authentication required to access the contacts server")
  - The `waiting_approval` field must be `false` when `auth_required` is `true` — these are mutually exclusive states
  - This field appears in responses from `POST /conversations`, `POST /conversations/:id/messages`, and `POST /approvals/:uuid`
- **Priority:** Must-have

### FR-006: Web UI OAuth2 Authorization Code Flow

- **Description:** The web server (`cmd/web`) must implement the OAuth2 authorization code flow with Google as the provider.
- **Inputs:** OAuth2 configuration from `config/web.yaml` (client_id, client_secret, auth_url, token_url, redirect_url, scopes)
- **Outputs:** Valid OAuth2 access token + refresh token stored in SQLite session
- **Business Rules:**
  - New routes: `GET /login` (starts OAuth2 flow), `GET /callback` (handles Google redirect)
  - `GET /login` must generate a cryptographically random `state` parameter for CSRF protection, store it in a short-lived cookie or server-side, and redirect to Google's auth URL with `access_type=offline` and `prompt=consent` to ensure a refresh token is returned
  - `GET /callback` must validate the `state` parameter, exchange the authorization code for tokens, create a session in SQLite, set the session cookie, and redirect to `/`
  - The `redirect_url` in the config must match exactly what is registered in the Google Cloud Console
  - Scopes are a flat list configured in `web.yaml`
- **Priority:** Must-have

### FR-007: Web UI SQLite Session Storage

- **Description:** The web server must store OAuth2 sessions in a SQLite database.
- **Inputs:** Session data (session ID, access token, refresh token, token expiry, creation time)
- **Outputs:** Persistent session storage at `<data_dir>/sessions.db`
- **Business Rules:**
  - SQLite database created at startup if it does not exist
  - Schema: `sessions` table with columns: `id TEXT PRIMARY KEY`, `access_token TEXT NOT NULL`, `refresh_token TEXT NOT NULL`, `token_expiry DATETIME NOT NULL`, `created_at DATETIME NOT NULL`, `updated_at DATETIME NOT NULL`
  - Session ID is a cryptographically random string (e.g., 32-byte hex)
  - Tokens are stored in plaintext
  - Use `modernc.org/sqlite` (pure Go, no CGO) — consistent with `mcp-resources`
- **Priority:** Must-have

### FR-008: Web UI Session Cookie

- **Description:** The web server must set a persistent session cookie after OAuth2 authentication.
- **Inputs:** Session ID from SQLite
- **Outputs:** Cookie set on the browser
- **Business Rules:**
  - Cookie name: `asg_session`
  - `HttpOnly: true` (no JavaScript access)
  - `SameSite: Lax` (allows OAuth2 callback redirect)
  - `Secure: false` for `localhost`, `true` otherwise
  - `Max-Age: 2592000` (30 days)
  - `Path: /`
- **Priority:** Must-have

### FR-009: Web UI Token Injection into Proxied Requests

- **Description:** The web server must read the session from the cookie and inject the OAuth2 Bearer token into proxied requests to the agent API.
- **Inputs:** Incoming request with `asg_session` cookie
- **Outputs:** Proxied request to agent API with `Authorization: Bearer <access_token>` header
- **Business Rules:**
  - On every proxied request (`/api/send`, `/api/approve`, `/api/conversation/:id`), read the session cookie
  - Look up the session in SQLite
  - If session exists and access token is not expired, inject `Authorization: Bearer <access_token>`
  - If session exists but access token is expired, attempt refresh (FR-010) before injecting
  - If no session or session not found, proxy without a Bearer token (non-auth tools still work)
- **Priority:** Must-have

### FR-010: Web UI Automatic Token Refresh

- **Description:** The web server must automatically refresh expired OAuth2 access tokens using the refresh token.
- **Inputs:** Session with expired access token and valid refresh token
- **Outputs:** Updated session with new access token (and possibly new refresh token)
- **Business Rules:**
  - Before proxying a request, check if `token_expiry` is in the past (or within a 60-second buffer to avoid race conditions)
  - If expired, call Google's token URL with `grant_type=refresh_token` and the stored refresh token
  - On success: update the session in SQLite with the new access token, new expiry, and new refresh token (if provided)
  - On failure (refresh token revoked/expired): delete the session from SQLite, clear the cookie, proxy without a Bearer token. If the MCP tool needs auth, SC-001 kicks in.
- **Priority:** Must-have

### FR-011: Web UI Auto-Retry After OAuth2 Flow

- **Description:** After completing the OAuth2 flow, the web UI must automatically retry the original message that triggered the auth-required response.
- **Inputs:** `auth_required: true` in the API response, pending message stored in browser `sessionStorage`
- **Outputs:** Original message retried with the new Bearer token
- **Business Rules:**
  - When the web UI JavaScript receives `auth_required: true` in a response, it must store the pending message and conversation ID in `sessionStorage` (key: `pending_auth_message`)
  - After the OAuth2 callback redirects back to `/`, the JavaScript must check for `pending_auth_message` in `sessionStorage`
  - If found, automatically re-send the message via the existing `/api/send` endpoint
  - Clear `pending_auth_message` from `sessionStorage` after sending
  - Include an `X-Auth-Retry: 1` header on the retry to enable infinite loop detection (FR-012)
- **Priority:** Must-have

### FR-012: Infinite Auth Loop Detection

- **Description:** Detect and break infinite auth loops where the MCP server keeps returning 401 despite valid tokens.
- **Inputs:** Retried request with `X-Auth-Retry` header that still triggers `auth_required`
- **Outputs:** Error message to the user instead of another redirect
- **Business Rules:**
  - The web UI must track the retry count per message. If the retry itself triggers `auth_required`, do not redirect again.
  - Maximum 1 OAuth2 retry per message. On the second `auth_required` for the same message, show an error: "Authentication failed. The server rejected your credentials. Please check that you are using the correct Google account and that the required permissions are granted."
  - The `X-Auth-Retry` header allows the web UI JavaScript to distinguish a first attempt from a retry.
- **Priority:** Must-have

### FR-013: Web UI Logout with Token Revocation

- **Description:** The web server must support logout with OAuth2 token revocation at Google.
- **Inputs:** `POST /logout` request from the browser
- **Outputs:** Session deleted, token revoked, cookie cleared
- **Business Rules:**
  - New route: `POST /logout`
  - Read the session from the cookie
  - Call Google's revocation endpoint (`POST https://oauth2.googleapis.com/revoke` with `token=<access_token>`)
  - If revocation fails (network error, Google down), log at WARN level and proceed with local cleanup
  - Delete the session from SQLite
  - Clear the `asg_session` cookie (set `Max-Age=0`)
  - Redirect to `/`
- **Priority:** Must-have

### FR-014: Web UI OAuth2 Configuration in web.yaml

- **Description:** The web.yaml configuration must support OAuth2 settings.
- **Inputs:** YAML configuration file
- **Outputs:** Parsed OAuth2 configuration available to the web server
- **Business Rules:**
  - New `oauth2` section in web.yaml:
    ```yaml
    oauth2:
      client_id: "xxx.apps.googleusercontent.com"
      client_secret: "GOCSPX-xxx"
      auth_url: "https://accounts.google.com/o/oauth2/v2/auth"
      token_url: "https://oauth2.googleapis.com/token"
      revoke_url: "https://oauth2.googleapis.com/revoke"
      redirect_url: "http://localhost:3000/callback"
      scopes:
        - "https://www.googleapis.com/auth/contacts"
    ```
  - If the `oauth2` section is absent, the web server starts without OAuth2 support (backward compatible). All auth-related routes (`/login`, `/callback`, `/logout`) return 404. The `auth_required` responses from the agent are displayed as plain error messages.
  - The web server must validate at startup that all required fields are present when `oauth2` is configured: `client_id`, `client_secret`, `auth_url`, `token_url`, `redirect_url`, and at least one scope.
- **Priority:** Must-have

### FR-015: Web UI Logout Button

- **Description:** The web UI must show a logout button when the user has an active session.
- **Inputs:** Session cookie presence
- **Outputs:** Visible logout button in the chat UI
- **Business Rules:**
  - When the user has a valid session cookie, the chat page must display a "Logout" button (or icon) in the header area
  - When the user does not have a session cookie, the button is not displayed
  - Clicking the button sends `POST /logout`
  - The web server can expose a `GET /api/session` endpoint that returns `{"authenticated": true/false}` for the frontend to check
- **Priority:** Should-have

### FR-016: Web UI Data Directory Configuration

- **Description:** The web.yaml configuration must support a `data_dir` setting for SQLite session storage.
- **Inputs:** YAML configuration
- **Outputs:** SQLite database created at `<data_dir>/sessions.db`
- **Business Rules:**
  - New `data_dir` field in web.yaml, defaults to `./data`
  - The web server must create the directory at startup if it does not exist
  - The SQLite database file is `<data_dir>/sessions.db`
- **Priority:** Must-have

## 6. Non-Functional Requirements

### 6.1 Performance

- Token refresh must complete within 5 seconds (Google's token endpoint typical latency is < 1s)
- The session lookup (SQLite read) must add less than 5ms latency to proxied requests
- No additional latency for unauthenticated requests (session lookup is skipped when no cookie is present)

### 6.2 Security

- OAuth2 client secret is stored in `web.yaml` (server-side only, never exposed to the browser)
- Session cookie is `HttpOnly` (no JavaScript access to the session ID)
- CSRF state parameter is validated on the OAuth2 callback to prevent CSRF attacks
- Tokens are stored server-side in SQLite — the browser never sees OAuth2 tokens
- `SameSite=Lax` prevents CSRF on mutation endpoints while allowing the OAuth2 callback redirect
- `Secure` cookie flag is set when not running on localhost
- OAuth2 tokens are stored in plaintext in SQLite (consistent with existing patterns for API keys)

### 6.3 Usability

- The OAuth2 flow is transparent — the user only sees the Google consent screen, then returns to the chat with their request already completed
- No login wall — users can use the chat immediately without authentication
- The logout button is only visible when the user has an active session
- Error messages for auth failures are clear and actionable ("Authentication failed. The server rejected your credentials...")

### 6.4 Reliability

- If Google's OAuth2 service is down, non-auth features continue to work normally
- If the refresh token is revoked, the system gracefully falls back to re-authentication (SC-001)
- If Google's revocation endpoint is down during logout, the session is still cleaned up locally
- Sessions persist across web server restarts (SQLite)

### 6.5 Observability

- 401 detection from MCP servers is logged at WARN level with the MCP server URL
- OAuth2 flow start/complete/failure events are logged at INFO level
- Token refresh success/failure is logged at INFO/WARN level respectively
- Session creation/deletion is logged at INFO level

### 6.6 Deployment

- No new services — changes are within existing `cmd/web` and `cmd/agent` binaries
- New dependency: `golang.org/x/oauth2` (standard Go OAuth2 library)
- SQLite dependency already exists via `modernc.org/sqlite`
- Docker Compose: `web.yaml` in the compose variant (`web-compose.yaml`) needs the `oauth2` section and a `data_dir` volume mount
- The `redirect_url` must be updated per environment (localhost for dev, actual domain for production)

### 6.7 Scalability

- SQLite session storage supports thousands of concurrent sessions (more than sufficient for the current single-instance deployment)
- No shared state between web server instances — if horizontal scaling is needed in the future, session storage must be externalized (out of scope for this spec)

## 7. Data Model

### 7.1 SQLite Sessions Table

| Column | Type | Description |
|--------|------|-------------|
| `id` | TEXT PRIMARY KEY | Cryptographically random session ID (32-byte hex) |
| `access_token` | TEXT NOT NULL | OAuth2 access token |
| `refresh_token` | TEXT NOT NULL | OAuth2 refresh token |
| `token_expiry` | DATETIME NOT NULL | Access token expiration timestamp (UTC) |
| `created_at` | DATETIME NOT NULL | Session creation timestamp (UTC) |
| `updated_at` | DATETIME NOT NULL | Last update timestamp (UTC) |

### 7.2 Web Configuration (web.yaml extension)

```yaml
agent_url: http://localhost:8080
host: 0.0.0.0
port: 3000
data_dir: ./data          # NEW: directory for sessions.db

oauth2:                    # NEW: entire section
  client_id: "xxx.apps.googleusercontent.com"
  client_secret: "GOCSPX-xxx"
  auth_url: "https://accounts.google.com/o/oauth2/v2/auth"
  token_url: "https://oauth2.googleapis.com/token"
  revoke_url: "https://oauth2.googleapis.com/revoke"
  redirect_url: "http://localhost:3000/callback"
  scopes:
    - "https://www.googleapis.com/auth/contacts"
```

### 7.3 ProcessResult Extension

```go
type ProcessResult struct {
    Response        string                        `json:"response"`
    WaitingApproval bool                          `json:"waiting_approval"`
    Approval        *conversation.PendingApproval `json:"approval,omitempty"`
    AuthRequired    bool                          `json:"auth_required"`  // NEW
}
```

### 7.4 A2A TaskStatus Extension

```go
// Existing states: "submitted", "input-required", "completed", "failed"
// New state: "auth-required"
```

### 7.5 MCP Client Interface Change

```go
// Before:
type Client interface {
    Start() error
    Stop() error
    Tools() []Tool
    GetTool(name string) *Tool
    CallTool(name string, args map[string]any) (*CallToolResult, error)
}

// After:
type Client interface {
    Start() error
    Stop() error
    Tools() []Tool
    GetTool(name string) *Tool
    CallTool(ctx context.Context, name string, args map[string]any) (*CallToolResult, error)
}
```

## 8. Documentation Requirements

All documentation listed below MUST be created or updated as part of this project.

### 8.1 README.md

- Update the web UI section to document OAuth2 configuration
- Add `oauth2` configuration example to the web.yaml documentation
- Document the `data_dir` setting

### 8.2 CLAUDE.md & .agent_docs/

- Update `CLAUDE.md` to mention OAuth2 token forwarding in the MCP client section
- Update `CLAUDE.md` to document the `auth-required` A2A state
- Update `CLAUDE.md` to document the `auth_required` REST API field
- Update `CLAUDE.md` web UI section to document new routes (`/login`, `/callback`, `/logout`, `/api/session`)
- Update `.agent_docs/` as needed for detailed OAuth2 flow documentation

### 8.3 docs/*

- Update `docs/authentication.md` to document the full OAuth2 token flow from web UI through the agent chain to MCP servers
- Update `docs/architecture.md` to reflect the new session storage in the web UI
- Update `docs/functionalities.md` to document the `auth_required` API response field and `auth-required` A2A state

## 9. Traceability Matrix

| Scenario | Functional Req | E2E Tests (Happy) | E2E Tests (Failure) | E2E Tests (Edge) |
|----------|---------------|-------------------|---------------------|-------------------|
| SC-001 | FR-003, FR-005, FR-006, FR-007, FR-008, FR-011, FR-014 | E2E-001 | E2E-007, E2E-008, E2E-009 | E2E-013, E2E-014 |
| SC-002 | FR-001, FR-002, FR-009 | E2E-002, E2E-003 | E2E-010 | E2E-015 |
| SC-003 | FR-010 | E2E-004 | E2E-011 | E2E-016 |
| SC-004 | FR-013, FR-015 | E2E-005 | E2E-012 | E2E-017 |
| SC-005 | FR-001, FR-002, FR-009, FR-014 | E2E-006 | — | E2E-018 |
| SC-006 | FR-004, FR-005 | E2E-003 | E2E-010 | E2E-019 |

## 10. End-to-End Test Suite

All tests MUST be implemented in the `tests/` directory or as Go E2E tests with `//go:build e2e` tags, consistent with existing E2E test patterns.

### 10.1 Test Summary

| Test ID | Category | Scenario | FR refs | Priority |
|---------|----------|----------|---------|----------|
| E2E-001 | Core Journey | SC-001 | FR-003, FR-005, FR-006, FR-007, FR-008, FR-011 | Critical |
| E2E-002 | Core Journey | SC-002 | FR-001, FR-002, FR-009 | Critical |
| E2E-003 | Core Journey | SC-002, SC-006 | FR-001, FR-002, FR-004 | Critical |
| E2E-004 | Core Journey | SC-003 | FR-010 | Critical |
| E2E-005 | Core Journey | SC-004 | FR-013 | High |
| E2E-006 | Core Journey | SC-005 | FR-001, FR-002, FR-009, FR-014 | High |
| E2E-007 | Failure | SC-001 | FR-006 | High |
| E2E-008 | Failure | SC-001 | FR-006 | High |
| E2E-009 | Failure | SC-001 | FR-006 | Medium |
| E2E-010 | Failure | SC-002, SC-006 | FR-003, FR-004 | High |
| E2E-011 | Failure | SC-003 | FR-010 | High |
| E2E-012 | Failure | SC-004 | FR-013 | Medium |
| E2E-013 | Edge Case | SC-001 | FR-012 | High |
| E2E-014 | Edge Case | SC-001 | FR-006, FR-008 | Medium |
| E2E-015 | Edge Case | SC-002 | FR-002 | Medium |
| E2E-016 | Edge Case | SC-003 | FR-010 | Medium |
| E2E-017 | Edge Case | SC-004 | FR-013, FR-015 | Low |
| E2E-018 | Edge Case | SC-005 | FR-014 | Medium |
| E2E-019 | Edge Case | SC-006 | FR-004 | High |
| E2E-020 | Security | SC-001 | FR-006, FR-008 | High |
| E2E-021 | Security | SC-002 | FR-002, FR-009 | High |

### 10.2 Test Specifications

#### E2E-001: On-Demand OAuth2 Flow — Full Journey

- **Category:** Core Journey
- **Scenario:** SC-001 — On-demand OAuth2 flow
- **Requirements:** FR-003, FR-005, FR-006, FR-007, FR-008, FR-011
- **Preconditions:** Web server running with OAuth2 config. Agent running with an MCP server that returns 401 without a token (mock MCP server). No existing session.
- **Steps:**
  - Given the user has no session cookie
  - And the agent is connected to a mock MCP server that returns HTTP 401 for any tool call without a Bearer token
  - When the user sends a message that triggers an MCP tool call via `POST /api/send`
  - Then the response contains `"auth_required": true`
  - And the response status is 200 (not an HTTP error)
  - When the user follows the OAuth2 flow (simulated: `GET /login` -> mock Google -> `GET /callback?code=valid&state=...`)
  - Then a session is created in SQLite
  - And the browser receives an `asg_session` cookie with `HttpOnly`, `SameSite=Lax`, `Max-Age=2592000`
  - When the user retries the original message via `POST /api/send`
  - Then the proxied request to the agent includes `Authorization: Bearer <access_token>`
  - And the mock MCP server receives the Bearer token
  - And the tool call succeeds
- **Priority:** Critical

#### E2E-002: Authenticated MCP Tool Call — Direct

- **Category:** Core Journey
- **Scenario:** SC-002 — Authenticated MCP tool call
- **Requirements:** FR-001, FR-002, FR-009
- **Preconditions:** Web server running. Agent running with mock MCP server. User has a valid session with a non-expired access token.
- **Steps:**
  - Given the user has a valid session cookie
  - And the session contains a valid access token
  - When the user sends a message via `POST /api/send`
  - Then the web server injects `Authorization: Bearer <access_token>` into the proxied request
  - And the agent passes the token through context to the MCP HTTP client
  - And the MCP HTTP client includes `Authorization: Bearer <access_token>` in the request to the MCP server
  - And the tool call succeeds
  - And the response contains the tool result (not `auth_required`)
- **Priority:** Critical

#### E2E-003: Authenticated MCP Tool Call — Through A2A Chain

- **Category:** Core Journey
- **Scenario:** SC-002, SC-006 — A2A chain with token forwarding
- **Requirements:** FR-001, FR-002, FR-004
- **Preconditions:** Agent-A running (orchestrator). Agent-B running with mock MCP server. Both connected via A2A. User has a valid session.
- **Steps:**
  - Given the user has a valid session with an access token
  - And Agent-A delegates to Agent-B via A2A
  - When the user sends a message that triggers A2A delegation
  - Then Agent-A forwards `Authorization: Bearer <token>` to Agent-B via A2A HTTP headers
  - And Agent-B passes the token to the MCP HTTP client
  - And the MCP server receives the Bearer token
  - And the tool call succeeds
  - And the result propagates back through Agent-B -> Agent-A -> Web UI
- **Priority:** Critical

#### E2E-004: Token Auto-Refresh

- **Category:** Core Journey
- **Scenario:** SC-003 — Token auto-refresh
- **Requirements:** FR-010
- **Preconditions:** User has a session with an expired access token and a valid refresh token. Mock Google token endpoint returns a new access token on refresh.
- **Steps:**
  - Given the user has a session with `token_expiry` in the past
  - And the session has a valid refresh token
  - When the user sends a message via `POST /api/send`
  - Then the web server detects the expired token
  - And the web server calls the mock Google token endpoint with `grant_type=refresh_token`
  - And the mock endpoint returns a new access token
  - And the session in SQLite is updated with the new token and expiry
  - And the proxied request includes the new access token
  - And the tool call succeeds
- **Priority:** Critical

#### E2E-005: Logout with Token Revocation

- **Category:** Core Journey
- **Scenario:** SC-004 — User logs out
- **Requirements:** FR-013
- **Preconditions:** User has a valid session.
- **Steps:**
  - Given the user has a valid session cookie
  - When the user sends `POST /logout`
  - Then the web server calls the mock Google revocation endpoint with the access token
  - And the session is deleted from SQLite
  - And the `asg_session` cookie is cleared (Max-Age=0)
  - And the user is redirected to `/`
  - When the user sends a subsequent message via `POST /api/send`
  - Then no Bearer token is injected into the proxied request
- **Priority:** High

#### E2E-006: Unauthenticated Usage — Non-Auth Tools Work

- **Category:** Core Journey
- **Scenario:** SC-005 — Unauthenticated usage
- **Requirements:** FR-001, FR-002, FR-009, FR-014
- **Preconditions:** Web server running with OAuth2 config. Agent connected to a mock MCP server that does NOT require auth. No session.
- **Steps:**
  - Given the user has no session cookie
  - And the agent is connected to an MCP server that does not require authentication
  - When the user sends a message that triggers a non-auth MCP tool call
  - Then the request is proxied without a Bearer token
  - And the tool call succeeds
  - And the response does not contain `auth_required`
- **Priority:** High

#### E2E-007: OAuth2 Callback — Invalid State Parameter (CSRF)

- **Category:** Failure
- **Scenario:** SC-001 — On-demand OAuth2 flow
- **Requirements:** FR-006
- **Preconditions:** OAuth2 flow initiated.
- **Steps:**
  - Given the user has started the OAuth2 flow via `GET /login`
  - When Google redirects to `GET /callback?code=valid&state=INVALID_STATE`
  - Then the web server rejects the callback (state mismatch)
  - And no session is created
  - And an error page is displayed with a "Try again" link
- **Priority:** High

#### E2E-008: OAuth2 Callback — Authorization Code Exchange Fails

- **Category:** Failure
- **Scenario:** SC-001 — On-demand OAuth2 flow
- **Requirements:** FR-006
- **Preconditions:** OAuth2 callback received with valid state.
- **Steps:**
  - Given the user completes Google consent
  - And the authorization code has expired (or the mock token endpoint returns an error)
  - When Google redirects to `GET /callback?code=expired&state=valid`
  - Then the web server attempts to exchange the code and receives an error from the token endpoint
  - And no session is created
  - And an error page is displayed with a "Try again" link
- **Priority:** High

#### E2E-009: OAuth2 — Google Service Unavailable

- **Category:** Failure
- **Scenario:** SC-001 — On-demand OAuth2 flow
- **Requirements:** FR-006
- **Preconditions:** Mock Google token endpoint is down/unreachable.
- **Steps:**
  - Given the user completes Google consent
  - When the web server attempts to exchange the code with the mock token endpoint
  - And the endpoint is unreachable (connection refused)
  - Then an error page is displayed with a message about the authentication service being unavailable
  - And the user can retry later
- **Priority:** Medium

#### E2E-010: MCP Returns 401 Despite Valid Token (Token Revoked Externally)

- **Category:** Failure
- **Scenario:** SC-002, SC-006 — Authenticated tool call fails
- **Requirements:** FR-003, FR-004
- **Preconditions:** User has a valid session. Mock MCP server is configured to return 401 even with a Bearer token.
- **Steps:**
  - Given the user has a valid session with an access token
  - And the mock MCP server returns 401 for all requests (simulating external token revocation)
  - When the user sends a message that triggers an MCP tool call
  - Then the agent detects the 401
  - And the response contains `auth_required: true`
  - And the web UI can trigger a new OAuth2 flow
- **Priority:** High

#### E2E-011: Refresh Token Revoked

- **Category:** Failure
- **Scenario:** SC-003 — Token auto-refresh
- **Requirements:** FR-010
- **Preconditions:** User has a session with an expired access token. Mock Google token endpoint rejects the refresh request.
- **Steps:**
  - Given the user has a session with an expired access token
  - And the mock Google token endpoint returns an error for the refresh request (refresh token revoked)
  - When the user sends a message via `POST /api/send`
  - Then the web server attempts to refresh and receives an error
  - And the session is deleted from SQLite
  - And the cookie is cleared
  - And the request is proxied without a Bearer token
  - And if the MCP tool requires auth, the response contains `auth_required: true`
- **Priority:** High

#### E2E-012: Logout — Revocation Endpoint Fails

- **Category:** Failure
- **Scenario:** SC-004 — User logs out
- **Requirements:** FR-013
- **Preconditions:** User has a valid session. Mock Google revocation endpoint is unreachable.
- **Steps:**
  - Given the user has a valid session
  - And the mock Google revocation endpoint is unreachable
  - When the user sends `POST /logout`
  - Then the web server attempts revocation and logs a warning
  - And the session is still deleted from SQLite
  - And the cookie is still cleared
  - And the user is redirected to `/`
- **Priority:** Medium

#### E2E-013: Infinite Auth Loop Detection

- **Category:** Edge Case
- **Scenario:** SC-001 — On-demand OAuth2 flow
- **Requirements:** FR-012
- **Preconditions:** User completes OAuth2 flow but the MCP server still returns 401 (wrong scopes).
- **Steps:**
  - Given the user has a valid session (just completed OAuth2)
  - And the mock MCP server always returns 401 regardless of the token
  - When the user sends a message (retry after OAuth2 flow, with `X-Auth-Retry: 1` header)
  - And the response contains `auth_required: true`
  - Then the web UI detects this is a second `auth_required` for the same message
  - And the web UI displays an error message instead of redirecting again
  - And the error message reads: "Authentication failed. The server rejected your credentials."
- **Priority:** High

#### E2E-014: OAuth2 Callback — Concurrent Sessions

- **Category:** Edge Case
- **Scenario:** SC-001 — On-demand OAuth2 flow
- **Requirements:** FR-006, FR-008
- **Preconditions:** Two browser tabs open.
- **Steps:**
  - Given Tab A triggers the OAuth2 flow and is redirected to Google
  - And Tab B sends a non-auth request (works normally)
  - When Tab A completes the OAuth2 flow and receives a session cookie
  - And Tab B sends a request that requires auth
  - Then Tab B uses the same session cookie (shared across tabs)
  - And the request includes the Bearer token
  - And the tool call succeeds
- **Priority:** Medium

#### E2E-015: Bearer Token Not Sent to Non-Auth MCP Servers

- **Category:** Edge Case
- **Scenario:** SC-002 — Authenticated tool call
- **Requirements:** FR-002
- **Preconditions:** Agent connected to two MCP servers. User has a session.
- **Steps:**
  - Given the user has a valid session with a Bearer token
  - And the agent is connected to both a mock auth-required MCP server and a mock no-auth MCP server
  - When the user triggers a tool call to the no-auth MCP server
  - Then the request to the no-auth MCP server still includes the Bearer token (the platform forwards tokens to all MCP servers — the server ignores it if not needed)
  - And the tool call succeeds
- **Priority:** Medium

#### E2E-016: Token Refresh Race Condition

- **Category:** Edge Case
- **Scenario:** SC-003 — Token auto-refresh
- **Requirements:** FR-010
- **Preconditions:** Token is about to expire (within 60-second buffer).
- **Steps:**
  - Given the user has a session with an access token expiring within 60 seconds
  - When the user sends a message
  - Then the web server proactively refreshes the token (60-second buffer)
  - And the updated token is used for the proxied request
  - And the tool call succeeds
- **Priority:** Medium

#### E2E-017: Logout Without Session

- **Category:** Edge Case
- **Scenario:** SC-004 — User logs out
- **Requirements:** FR-013, FR-015
- **Preconditions:** No session exists.
- **Steps:**
  - Given the user has no session cookie
  - When the user sends `POST /logout`
  - Then the web server returns gracefully (no error, redirect to `/`)
  - And no revocation call is made
- **Priority:** Low

#### E2E-018: Web Server Without OAuth2 Config

- **Category:** Edge Case
- **Scenario:** SC-005 — Unauthenticated usage
- **Requirements:** FR-014
- **Preconditions:** Web server running with web.yaml that has NO `oauth2` section.
- **Steps:**
  - Given the web server is configured without an `oauth2` section
  - When the user sends a message that triggers a tool call on an auth-required MCP server
  - And the agent returns `auth_required: true`
  - Then the web UI displays the auth-required message as a plain error (no redirect)
  - And `GET /login` returns 404
  - And `GET /callback` returns 404
  - And `POST /logout` returns 404
- **Priority:** Medium

#### E2E-019: A2A Chain Auth-Required Propagation

- **Category:** Edge Case
- **Scenario:** SC-006 — A2A chain auth-required propagation
- **Requirements:** FR-004
- **Preconditions:** Agent-A and Agent-B running. Agent-B's MCP server returns 401. No session.
- **Steps:**
  - Given Agent-A delegates to Agent-B via A2A
  - And Agent-B is connected to a mock MCP server that returns 401
  - And no Bearer token is provided
  - When the user sends a message via Agent-A
  - Then Agent-B detects the 401 and returns A2A task with `state: "auth-required"`
  - And Agent-A receives the `auth-required` state
  - And Agent-A's API response includes `auth_required: true`
  - And the response does not include `waiting_approval: true` (these are mutually exclusive)
- **Priority:** High

#### E2E-020: CSRF State Validation

- **Category:** Security
- **Scenario:** SC-001 — On-demand OAuth2 flow
- **Requirements:** FR-006, FR-008
- **Preconditions:** OAuth2 flow initiated.
- **Steps:**
  - Given the user initiates the OAuth2 flow via `GET /login`
  - Then a cryptographically random state parameter is generated
  - And the redirect to Google includes the state parameter
  - When an attacker sends `GET /callback?code=stolen&state=FORGED`
  - Then the web server rejects the callback (state mismatch)
  - And no session is created
- **Priority:** High

#### E2E-021: Token Not Leaked to Browser

- **Category:** Security
- **Scenario:** SC-002 — Authenticated tool call
- **Requirements:** FR-002, FR-009
- **Preconditions:** User has a valid session.
- **Steps:**
  - Given the user has a valid session
  - When the user inspects the `asg_session` cookie
  - Then the cookie value is only a session ID (not the OAuth2 token)
  - And the cookie has `HttpOnly` flag (not accessible via `document.cookie`)
  - When the user sends a request via `POST /api/send`
  - Then the API response does not contain the OAuth2 access token or refresh token
- **Priority:** High

## 11. Open Questions & TBDs

- **TBD-001:** The `mcp-go` library's HTTP transport may not natively support injecting custom headers (like `Authorization`) per request. Investigation needed: does `transport.NewStreamableHTTP()` accept a custom `http.Client` or `http.RoundTripper` where headers can be injected? If not, a wrapper or fork may be needed.
- **TBD-002:** Session cleanup strategy — should expired sessions (where the refresh token has also expired) be cleaned up automatically? If so, via a background goroutine (e.g., every 24 hours) or lazily on access? This is low priority and can be deferred.
- **TBD-003:** The `StdioClient` transport does not have HTTP headers. If an MCP server running over stdio requires auth in the future, a different mechanism would be needed. For now, only `HTTPClient` forwards tokens.

## 12. Glossary

| Term | Definition |
|------|-----------|
| **Bearer token** | An OAuth2 access token sent in the `Authorization: Bearer <token>` HTTP header |
| **Authorization code flow** | OAuth2 grant type where the user is redirected to the provider, consents, and the server exchanges a code for tokens |
| **Refresh token** | A long-lived token used to obtain new access tokens without user interaction |
| **CSRF state parameter** | A random value included in the OAuth2 redirect to prevent Cross-Site Request Forgery attacks |
| **On-demand auth** | Authentication is not required upfront — it is triggered only when a tool requires it |
| **auth-required** | A2A task state (per A2A spec RC v1.0) indicating the task cannot proceed without user authentication |
| **Session cookie** | An `HttpOnly` cookie containing only the session ID (not the OAuth2 token) |
| **Token revocation** | Calling the OAuth2 provider's revocation endpoint to invalidate a token |
| **mcp-go** | The Go library (`github.com/mark3labs/mcp-go`) used for MCP Streamable HTTP transport |
