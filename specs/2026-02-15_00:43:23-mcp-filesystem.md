# MCP Filesystem Server — Specification Document

> Generated on: 2026-02-15
> Version: 1.0
> Status: Draft

## 1. Executive Summary

The MCP Filesystem Server (`mcp-filesystem`) is a new MCP Streamable HTTP server for the Agent Stop and Go agentic platform. It provides sandboxed local file and folder operations with a chroot-like security model. The server exposes 14 tools covering file reading, writing, patching, searching, and metadata inspection — all confined to one or more named root directories with per-root tool allowlists.

The primary consumer is the platform's LLM agent, which uses these tools autonomously without human approval. Security relies on three layers: chroot-style path confinement, realpath-based symlink escape prevention, and per-root tool allowlists. There is no destructiveHint gating — agents operate freely within their sandbox boundaries.

## 2. Scope

### 2.1 In Scope

- MCP Streamable HTTP server exposing 14 filesystem tools
- Chroot-like security model with realpath validation on every operation
- Multiple named roots per server instance, each with an independent tool allowlist
- Byte-based and line-based partial file reading
- Unified diff patch application
- Content search (grep) with regex, context lines, case sensitivity, file type filter, binary skip
- File search (glob) with glob patterns and regex
- Search safeguards: result count limit, timeout, optional depth limit
- Cross-root copy and move operations (subject to allowlists on both roots)
- Three write modes: overwrite, append, create_only
- File hashing with md5, sha1, sha256
- YAML configuration following existing platform patterns
- Structured logging via `slog` with JSON output
- Docker support
- Makefile integration (automatic via existing `cmd/` discovery)

### 2.2 Out of Scope (Non-Goals)

- Approval workflow integration (all tools have `destructiveHint=false`)
- File watching or event notifications (inotify, fsnotify)
- Compression or archive operations (tar, zip, gzip)
- File permission modification (chmod, chown) — only reading permissions is supported
- Network filesystem support (NFS, CIFS, S3)
- File locking mechanisms (advisory or mandatory)
- Encryption or decryption of file contents
- Streaming / chunked transfer of large files
- A2A protocol support (this is a pure MCP server)

## 3. User Personas & Actors

### 3.1 LLM Agent (Primary)

The platform's LLM agent is the primary consumer. It discovers filesystem tools via MCP and invokes them autonomously to read, write, search, and manage files within sandboxed root directories. The agent operates without human approval for any filesystem operation.

### 3.2 Platform Operator (Configuration)

The human who configures and deploys the MCP server. They define root directories, tool allowlists, and operational parameters (thresholds, timeouts) via the YAML config file. They do not interact with the MCP protocol directly.

### 3.3 Agent Platform (Integration)

The `cmd/agent` process that connects to `mcp-filesystem` as an MCP client. It discovers available tools, forwards tool calls from the LLM, and returns results. Configuration references `mcp-filesystem` via `mcp.url` in the agent config.

## 4. Usage Scenarios

### 4.1 US-001: Read a source code file

**Actor:** LLM Agent
**Preconditions:** A root `workspace` is configured with `read_file` allowed. The file exists and is under 1MB.
**Flow:**
1. Agent calls `read_file` with `root=workspace`, `path=src/main.go`
2. Server resolves the real path, validates it is within the `workspace` root
3. Server checks that `read_file` is in the allowlist for `workspace`
4. Server checks file size against `max_full_read_size` threshold
5. File is under the threshold; server returns full content with line numbers
**Postconditions:** Agent receives the file content as a text result.
**Exceptions:**
- File does not exist: error with message "file not found: src/main.go"
- File exceeds threshold: error with message "file too large for full read (size: 5.2MB, limit: 1MB); use offset/limit parameters"
- Path escapes root via symlink: error with message "path resolves outside root boundary"

### 4.2 US-002: Partial read of a large log file

**Actor:** LLM Agent
**Preconditions:** A root `logs` is configured with `read_file` allowed. A large log file exists.
**Flow:**
1. Agent calls `read_file` with `root=logs`, `path=app.log`, `offset_lines=1000`, `limit_lines=50`
2. Server resolves and validates the path
3. Server reads lines 1000-1049 from the file
4. Server returns the 50 lines with their line numbers
**Postconditions:** Agent receives the requested line range.
**Exceptions:**
- Offset beyond file length: returns empty content with a note indicating total line count

### 4.3 US-003: Write a new configuration file

**Actor:** LLM Agent
**Preconditions:** A root `workspace` is configured with `write_file` allowed.
**Flow:**
1. Agent calls `write_file` with `root=workspace`, `path=config/app.yaml`, `content=...`, `mode=create_only`
2. Server resolves and validates the path
3. Server checks the file does not already exist (`create_only` mode)
4. Server creates parent directories if needed
5. Server writes the content to the file
**Postconditions:** File is created with the provided content.
**Exceptions:**
- File already exists in `create_only` mode: error "file already exists: config/app.yaml; use overwrite mode to replace"
- Parent directory creation fails (permission denied at OS level): error with OS message
- Tool `write_file` not in allowlist: error "tool write_file not allowed on root workspace"

### 4.4 US-004: Apply a unified diff patch

**Actor:** LLM Agent
**Preconditions:** A root `workspace` is configured with `patch_file` allowed. A source file exists.
**Flow:**
1. Agent calls `patch_file` with `root=workspace`, `path=src/handler.go`, `patch=<unified diff>`
2. Server resolves and validates the path
3. Server reads the current file content (or treats as empty if file doesn't exist)
4. Server applies the unified diff
5. Server writes the patched content back
**Postconditions:** File content is updated according to the diff.
**Exceptions:**
- Patch does not apply cleanly (context mismatch): error "patch failed: hunk 1 does not match at line 42"
- File doesn't exist: patch is applied against empty content (creation)

### 4.5 US-005: Search for a pattern across a codebase

**Actor:** LLM Agent
**Preconditions:** A root `workspace` is configured with `grep` allowed.
**Flow:**
1. Agent calls `grep` with `root=workspace`, `pattern=TODO|FIXME`, `glob_filter=*.go`, `context_lines=2`, `case_insensitive=true`
2. Server resolves the root path
3. Server walks the directory tree, filtering by `*.go` files, skipping binary files
4. Server searches for the regex pattern with case-insensitive matching
5. Server collects matches with 2 lines of context before and after
6. Server returns results up to the result limit (default 100)
**Postconditions:** Agent receives a list of matches with file path, line number, matching line, and context.
**Exceptions:**
- No matches found: returns empty result set with count 0
- Search times out (5 min default): returns partial results collected so far with a "timeout" flag
- Invalid regex: error "invalid pattern: <regex error message>"

### 4.6 US-006: Copy a file across roots

**Actor:** LLM Agent
**Preconditions:** Roots `workspace` and `backup` are configured. `workspace` allows `copy` (read side). `backup` allows `copy` (write side).
**Flow:**
1. Agent calls `copy` with `source_root=workspace`, `source_path=data/report.csv`, `dest_root=backup`, `dest_path=data/report.csv`
2. Server validates source path within `workspace` root
3. Server validates destination path within `backup` root
4. Server checks `copy` is in the allowlist for both roots
5. Server reads the source file and writes to the destination
**Postconditions:** File exists in both roots with identical content.
**Exceptions:**
- Source file doesn't exist: error "source file not found"
- Destination file already exists: overwritten (copy always overwrites)
- Copy not allowed on destination root: error "tool copy not allowed on root backup"

### 4.7 US-007: Remove a directory recursively

**Actor:** LLM Agent
**Preconditions:** A root `workspace` is configured with `remove_folder` allowed.
**Flow:**
1. Agent calls `remove_folder` with `root=workspace`, `path=tmp/build-output`
2. Server resolves and validates the path
3. Server removes the directory and all its contents recursively
**Postconditions:** Directory and all contents are deleted.
**Exceptions:**
- Path is the root directory itself: error "cannot remove root directory"
- Path does not exist: error "directory not found"

### 4.8 US-008: Get file metadata and hash

**Actor:** LLM Agent
**Preconditions:** A root `workspace` is configured with `stat_file` and `hash_file` allowed.
**Flow:**
1. Agent calls `stat_file` with `root=workspace`, `path=data/input.json`
2. Server returns: size, modification time, creation time, is_directory, is_symlink
3. Agent calls `hash_file` with `root=workspace`, `path=data/input.json`, `algorithm=sha256`
4. Server computes and returns the SHA-256 hash
**Postconditions:** Agent has file metadata and integrity hash.
**Exceptions:**
- File not found: error for both tools
- Unsupported algorithm: error "unsupported hash algorithm: md4; supported: md5, sha1, sha256"

### 4.9 US-009: Discover available tools for a root

**Actor:** LLM Agent
**Preconditions:** Server is running with multiple roots configured.
**Flow:**
1. Agent discovers tools via MCP tool listing
2. Each tool description includes a note that a `root` parameter is required
3. Agent can call `list_roots` (a meta-tool) to see available roots and their allowed tools
**Postconditions:** Agent knows which roots exist and what operations are available on each.

### 4.10 US-010: Attempt a disallowed operation

**Actor:** LLM Agent
**Preconditions:** A root `config` is configured with only `["list_folder", "read_file", "stat_file"]` allowed.
**Flow:**
1. Agent calls `write_file` with `root=config`, `path=app.yaml`, `content=...`
2. Server checks the allowlist for `config`
3. `write_file` is not in the allowlist
4. Server returns an error
**Postconditions:** File is not modified. Agent receives a clear error.
**Exceptions:** N/A — this scenario IS the exception path.

### 4.11 US-011: Attempt path traversal via symlink

**Actor:** LLM Agent (or malicious input)
**Preconditions:** A root `workspace` is configured at `/data/workspace`. A symlink `/data/workspace/escape` points to `/etc`.
**Flow:**
1. Agent calls `read_file` with `root=workspace`, `path=escape/passwd`
2. Server resolves realpath: `/data/workspace/escape/passwd` -> `/etc/passwd`
3. `/etc/passwd` is not under `/data/workspace`
4. Server rejects the request
**Postconditions:** No data is returned. Agent receives a security error.

## 5. Functional Requirements

### FR-001: Root Path Validation (Security Core)

- **Description:** Every tool call MUST resolve the target path to its real absolute path (following symlinks) and verify it falls within the boundaries of the specified root directory. This check MUST occur before any filesystem operation.
- **Inputs:** Root name, relative path
- **Outputs:** Resolved absolute path (if valid) or security error
- **Business Rules:**
  - Use `filepath.EvalSymlinks()` + `filepath.Abs()` to resolve the real path
  - The resolved path MUST have the root's absolute path as a prefix (using `strings.HasPrefix` on the cleaned paths)
  - Paths containing `..` segments MUST be resolved before validation (not rejected outright — `a/../b` is valid if `b` is within root)
  - The root directory path itself MUST be resolved via realpath at server startup
  - If the target file does not yet exist (write, create_folder), validate the nearest existing ancestor directory
  - This function MUST be called by every tool handler before any I/O operation
- **Priority:** Must-have

### FR-002: Per-Root Tool Allowlist

- **Description:** Each root directory has a configurable list of allowed tools. A tool call MUST be rejected if the tool is not in the allowlist for the specified root.
- **Inputs:** Root name, tool name
- **Outputs:** Allowed (proceed) or rejected (error)
- **Business Rules:**
  - The allowlist is defined per root in the YAML config as `allowed_tools: [...]`
  - The wildcard value `"*"` means all tools are allowed
  - Allowlist check MUST occur after root validation but before path validation
  - Error message MUST identify both the tool and the root: "tool {tool} not allowed on root {root}"
  - Cross-root operations (copy, move) MUST check allowlists on both source and destination roots
- **Priority:** Must-have

### FR-003: List Roots (Meta-Tool)

- **Description:** A meta-tool `list_roots` that returns all configured roots with their names and allowed tools. This helps the LLM agent discover what's available.
- **Inputs:** None
- **Outputs:** JSON array of root objects: `{ name, allowed_tools }`
- **Business Rules:**
  - Does not expose the actual filesystem paths (security: the agent doesn't need to know the host paths)
  - Always available regardless of root allowlists
  - `destructiveHint=false`, `readOnlyHint=true`
- **Priority:** Must-have

### FR-004: List Folder

- **Description:** List the contents of a directory within a root.
- **Inputs:** `root` (string, required), `path` (string, required — use `""` or `"."` for root directory)
- **Outputs:** JSON array of entries, each with: `name`, `type` (file/directory/symlink), `size` (bytes), `modified_at` (ISO 8601)
- **Business Rules:**
  - Only lists immediate children (not recursive — use `glob` for recursive listing)
  - Entries are sorted alphabetically
  - Symlinks report their type as `symlink` with an additional `target_type` field (file/directory) if the target is within root, or `external` if outside
  - Returns an error if the path is not a directory
- **Priority:** Must-have

### FR-005: Read File

- **Description:** Read the contents of a file, either fully or partially using byte or line offsets.
- **Inputs:**
  - `root` (string, required)
  - `path` (string, required)
  - `offset_bytes` (integer, optional) — byte offset to start reading from
  - `limit_bytes` (integer, optional) — maximum number of bytes to read
  - `offset_lines` (integer, optional) — line number to start reading from (1-based)
  - `limit_lines` (integer, optional) — maximum number of lines to read
- **Outputs:** File content as text, with metadata: `size` (total file size), `lines_total` (if line-based), `truncated` (boolean)
- **Business Rules:**
  - Byte-based and line-based parameters are mutually exclusive; providing both is an error
  - If no offset/limit is provided, this is a "full read" — subject to `max_full_read_size` threshold
  - If file size exceeds `max_full_read_size` and no offset/limit is given: return error with file size, prompting partial read
  - Line offsets are 1-based (line 1 is the first line)
  - Reading beyond the end of file returns what's available without error
  - Binary file detection: if the first 8KB contain a null byte, include a `binary: true` flag in the response
- **Priority:** Must-have

### FR-006: Write File

- **Description:** Write content to a file with three modes: overwrite, append, create_only.
- **Inputs:**
  - `root` (string, required)
  - `path` (string, required)
  - `content` (string, required)
  - `mode` (string, optional, default `"overwrite"`) — one of: `overwrite`, `append`, `create_only`
- **Outputs:** Confirmation with: `path`, `size` (bytes written), `mode`
- **Business Rules:**
  - `overwrite`: replaces file content entirely; creates file if it doesn't exist
  - `append`: adds content to the end of the file; creates file if it doesn't exist
  - `create_only`: creates the file only if it doesn't exist; returns error if file exists
  - Parent directories MUST be created automatically if they don't exist (like `mkdir -p`)
  - Invalid mode value returns an error listing valid modes
- **Priority:** Must-have

### FR-007: Remove File

- **Description:** Delete a single file.
- **Inputs:** `root` (string, required), `path` (string, required)
- **Outputs:** Confirmation with: `path`, `removed: true`
- **Business Rules:**
  - Returns error if path is a directory (use `remove_folder` instead)
  - Returns error if file does not exist
- **Priority:** Must-have

### FR-008: Patch File (Unified Diff)

- **Description:** Apply a unified diff patch to a file.
- **Inputs:**
  - `root` (string, required)
  - `path` (string, required)
  - `patch` (string, required) — unified diff format content
- **Outputs:** Confirmation with: `path`, `hunks_applied` (count)
- **Business Rules:**
  - If the target file does not exist, treat it as patching an empty file (creation)
  - Patch MUST apply cleanly — if any hunk fails, the entire operation fails and the file is unchanged (atomic: all or nothing)
  - The patch format follows standard unified diff: `---`, `+++`, `@@` hunk headers, context lines, `+` additions, `-` deletions
  - Parent directories MUST be created automatically if they don't exist
  - Return clear error on hunk failure: which hunk failed and at which line
- **Priority:** Must-have

### FR-009: Create Folder

- **Description:** Create a directory (and any missing parent directories).
- **Inputs:** `root` (string, required), `path` (string, required)
- **Outputs:** Confirmation with: `path`, `created: true`
- **Business Rules:**
  - Creates all missing parent directories (like `mkdir -p`)
  - If directory already exists, return success (idempotent)
  - Returns error if path exists and is a file
- **Priority:** Must-have

### FR-010: Remove Folder

- **Description:** Remove a directory and all its contents recursively.
- **Inputs:** `root` (string, required), `path` (string, required)
- **Outputs:** Confirmation with: `path`, `removed: true`
- **Business Rules:**
  - Removes directory and all contents recursively (like `rm -rf`)
  - Returns error if path is the root directory itself (cannot remove root)
  - Returns error if path does not exist
  - Returns error if path is a file (use `remove_file` instead)
  - Every path encountered during recursive deletion MUST be validated against the root boundary (defense in depth against symlink attacks within the tree)
- **Priority:** Must-have

### FR-011: Stat File

- **Description:** Return metadata about a file or directory.
- **Inputs:** `root` (string, required), `path` (string, required)
- **Outputs:** JSON object with: `name`, `path`, `size` (bytes), `is_directory` (boolean), `is_symlink` (boolean), `modified_at` (ISO 8601), `created_at` (ISO 8601, if available from OS)
- **Business Rules:**
  - Works on both files and directories
  - For symlinks, reports both the symlink info and the target info
  - Size for directories is the OS-reported directory entry size (not recursive total)
- **Priority:** Must-have

### FR-012: Hash File

- **Description:** Compute a cryptographic hash of a file's contents.
- **Inputs:**
  - `root` (string, required)
  - `path` (string, required)
  - `algorithm` (string, required) — one of: `md5`, `sha1`, `sha256`
- **Outputs:** JSON object with: `path`, `algorithm`, `hash` (hex-encoded string), `size` (file size)
- **Business Rules:**
  - The hash is computed by streaming the file (not loading entirely into memory)
  - Unsupported algorithm returns error listing valid options
  - Returns error if path is a directory
- **Priority:** Must-have

### FR-013: File Permissions

- **Description:** Return the owner, group, and permission bits of a file or directory.
- **Inputs:** `root` (string, required), `path` (string, required)
- **Outputs:** JSON object with: `path`, `owner` (username), `group` (group name), `mode` (octal string, e.g., "0644"), `mode_string` (symbolic, e.g., "-rw-r--r--")
- **Business Rules:**
  - Works on files, directories, and symlinks
  - On systems where owner/group lookup is unavailable, return numeric UID/GID
- **Priority:** Must-have

### FR-014: Copy

- **Description:** Copy a file or directory from one location to another, potentially across roots.
- **Inputs:**
  - `source_root` (string, required)
  - `source_path` (string, required)
  - `dest_root` (string, required)
  - `dest_path` (string, required)
- **Outputs:** Confirmation with: `source`, `destination`, `is_directory` (boolean), `size` (bytes, for files)
- **Business Rules:**
  - Cross-root copy is allowed, subject to allowlist checks on both roots
  - Source root MUST have `copy` in its allowlist (read side)
  - Destination root MUST have `copy` in its allowlist (write side)
  - Copying a directory copies it recursively
  - If destination exists and is a file, it is overwritten
  - If destination exists and is a directory, the source is copied into it
  - Parent directories at the destination are created automatically
  - All paths (source + destination + recursive contents) MUST be validated against their respective root boundaries
- **Priority:** Must-have

### FR-015: Move

- **Description:** Move (rename) a file or directory, potentially across roots.
- **Inputs:**
  - `source_root` (string, required)
  - `source_path` (string, required)
  - `dest_root` (string, required)
  - `dest_path` (string, required)
- **Outputs:** Confirmation with: `source`, `destination`
- **Business Rules:**
  - Cross-root move is allowed, subject to allowlist checks on both roots
  - Source root MUST have `move` in its allowlist
  - Destination root MUST have `move` in its allowlist
  - Same-root move uses OS rename (atomic when possible)
  - Cross-root move is implemented as copy + delete (not atomic)
  - If destination exists and is a file, it is overwritten
  - All paths MUST be validated against their respective root boundaries
- **Priority:** Must-have

### FR-016: Grep (Content Search)

- **Description:** Search for a regex pattern within files under a root directory.
- **Inputs:**
  - `root` (string, required)
  - `pattern` (string, required) — Go-compatible regular expression
  - `path` (string, optional, default `"."`) — subdirectory to search within
  - `glob_filter` (string, optional) — glob pattern to filter files (e.g., `*.go`)
  - `case_insensitive` (boolean, optional, default `false`)
  - `context_lines` (integer, optional, default `0`) — lines of context before and after each match
  - `max_results` (integer, optional, default `100`) — maximum number of matches to return
  - `timeout_seconds` (integer, optional, default `300`) — maximum search duration in seconds
  - `max_depth` (integer, optional) — maximum directory depth to traverse
- **Outputs:** JSON object with: `matches` (array of match objects), `total_matches` (count), `truncated` (boolean), `timed_out` (boolean)
  - Each match: `file`, `line_number`, `line_content`, `context_before` (array), `context_after` (array)
- **Business Rules:**
  - Binary files (containing null bytes in first 8KB) are skipped automatically
  - Invalid regex returns an error with the parse error message
  - If max_results is reached, stop searching and set `truncated=true`
  - If timeout is reached, return results collected so far and set `timed_out=true`
  - All traversed paths MUST be validated against root boundary
- **Priority:** Must-have

### FR-017: Glob (File Search)

- **Description:** Search for files by name pattern within a root directory.
- **Inputs:**
  - `root` (string, required)
  - `pattern` (string, optional) — glob pattern (e.g., `**/*.go`)
  - `regex` (string, optional) — regex pattern matched against relative file paths
  - `path` (string, optional, default `"."`) — subdirectory to search within
  - `max_results` (integer, optional, default `100`) — maximum results to return
  - `timeout_seconds` (integer, optional, default `300`) — maximum search duration
  - `max_depth` (integer, optional) — maximum directory depth
  - `type_filter` (string, optional) — filter by entry type: `file`, `directory`, `symlink`, or `all` (default `all`)
- **Outputs:** JSON object with: `matches` (array of file info objects), `total_matches` (count), `truncated` (boolean), `timed_out` (boolean)
  - Each match: `path` (relative), `type`, `size`, `modified_at`
- **Business Rules:**
  - Exactly one of `pattern` or `regex` MUST be provided; providing both or neither is an error
  - `**` in glob patterns matches any number of directories (doublestar semantics)
  - Results are sorted alphabetically by path
  - If max_results is reached, stop and set `truncated=true`
  - If timeout is reached, return partial results and set `timed_out=true`
  - All traversed paths MUST be validated against root boundary
- **Priority:** Must-have

### FR-018: Configuration Loading

- **Description:** The server MUST load its configuration from a YAML file, with CLI flag overrides.
- **Inputs:** YAML config file path (via `--config` flag), optional `--port` override
- **Outputs:** Validated configuration struct
- **Business Rules:**
  - Config structure as defined in Section 7
  - Root paths MUST be resolved to absolute real paths at startup (fail fast if path doesn't exist or is inaccessible)
  - Root names MUST be unique; duplicate names cause a startup error
  - An empty `roots` list causes a startup error
  - `allowed_tools` values MUST be validated against the known tool names; unknown tool names cause a startup error (typo protection)
  - `max_full_read_size` is a top-level config option, default `1048576` (1MB), specified in bytes
  - Defaults: host `0.0.0.0`, port `8091`
- **Priority:** Must-have

### FR-019: Health Endpoint

- **Description:** An HTTP health check endpoint at `/health`.
- **Inputs:** GET request
- **Outputs:** HTTP 200 with body `ok`
- **Business Rules:**
  - Always returns 200 if the server is running
  - Does not check filesystem accessibility (fast, unconditional)
- **Priority:** Must-have

## 6. Non-Functional Requirements

### 6.1 Performance

- **NFR-001:** Read operations on files under 1MB MUST complete within 100ms (excluding network latency).
- **NFR-002:** Directory listing of folders with up to 10,000 entries MUST complete within 1 second.
- **NFR-003:** Hash computation MUST stream the file in chunks (max 32KB buffer) — never load the entire file into memory.
- **NFR-004:** Grep and glob operations MUST respect the configurable timeout (default 300 seconds) and return partial results if the deadline is exceeded.
- **NFR-005:** The server MUST handle at least 50 concurrent tool calls without degradation (limited by OS filesystem I/O, not application locks).

### 6.2 Security

- **NFR-006:** Every tool call MUST validate the resolved real path against the root boundary before any I/O. No exceptions.
- **NFR-007:** Symlinks MUST be resolved via `filepath.EvalSymlinks()`. Paths resolving outside the root MUST be rejected.
- **NFR-008:** The `list_roots` tool MUST NOT expose host filesystem paths — only root names and allowed tools.
- **NFR-009:** Recursive operations (remove_folder, copy directory, grep, glob) MUST validate each path encountered during traversal, not just the entry point.
- **NFR-010:** Path validation MUST handle all bypass attempts: `..` sequences, symlink chains, double encoding, null bytes in paths.

### 6.3 Usability

- **NFR-011:** All tool error messages MUST be specific and actionable — include the root name, path, and reason for failure.
- **NFR-012:** Tool descriptions registered with MCP MUST be clear and complete, enabling an LLM to use them correctly without additional documentation.
- **NFR-013:** All JSON responses MUST use consistent field naming (snake_case) and include relevant metadata (sizes, counts, timestamps).

### 6.4 Reliability

- **NFR-014:** Write operations that fail mid-way MUST NOT leave partially written files. Use write-to-temp-then-rename for atomic writes where possible.
- **NFR-015:** Patch operations MUST be atomic: if any hunk fails, the original file MUST remain unchanged.
- **NFR-016:** The server MUST start successfully even if some root directories are empty (but they MUST exist).

### 6.5 Observability

- **NFR-017:** All tool calls MUST be logged via `slog` with JSON output, including: tool name, root name, path, outcome (success/error), duration, and response size.
- **NFR-018:** Startup MUST log: server address, configured roots (names only, not paths — security), and config file path.
- **NFR-019:** Security violations (path escapes, allowlist denials) MUST be logged at WARN level with full details (tool, root, attempted path, resolved path).

### 6.6 Deployment

- **NFR-020:** The server MUST be buildable via the existing `make build` target (automatic via `cmd/` directory discovery).
- **NFR-021:** The server MUST be runnable via `make run CMD=mcp-filesystem`.
- **NFR-022:** The server MUST be containerizable via the existing `Dockerfile` and `make docker-build`.
- **NFR-023:** A config file `config/mcp-filesystem.yaml` MUST be provided with sensible defaults for local development.

### 6.7 Scalability

- **NFR-024:** The server is designed for single-instance deployment. Horizontal scaling is a non-goal for v1.
- **NFR-025:** Adding new tools in the future MUST require only: adding the tool handler, registering it with MCP, and adding the tool name to the allowlist validation set.

## 7. Data Model

### 7.1 Configuration Schema

```yaml
host: "0.0.0.0"                    # Listen address (default: 0.0.0.0)
port: 8091                          # Listen port (default: 8091)
max_full_read_size: 1048576         # Max bytes for full file read (default: 1MB)

roots:
  - name: "workspace"               # Unique root identifier
    path: "/data/workspace"          # Absolute host filesystem path
    allowed_tools:                   # Tool allowlist (* = all)
      - "*"
  - name: "config"
    path: "/etc/myapp"
    allowed_tools:
      - "list_folder"
      - "read_file"
      - "stat_file"
      - "grep"
      - "glob"
  - name: "logs"
    path: "/var/log/myapp"
    allowed_tools:
      - "list_folder"
      - "read_file"
      - "stat_file"
      - "grep"
```

### 7.2 Valid Tool Names

The following are the recognized tool names for use in `allowed_tools`:

`list_folder`, `read_file`, `write_file`, `remove_file`, `patch_file`, `create_folder`, `remove_folder`, `stat_file`, `hash_file`, `permissions_file`, `copy`, `move`, `grep`, `glob`

The meta-tool `list_roots` is always available and cannot be restricted.

### 7.3 Go Configuration Struct

```go
type Config struct {
    Host             string `yaml:"host"`
    Port             int    `yaml:"port"`
    MaxFullReadSize  int64  `yaml:"max_full_read_size"`
    Roots            []Root `yaml:"roots"`
}

type Root struct {
    Name         string   `yaml:"name"`
    Path         string   `yaml:"path"`
    AllowedTools []string `yaml:"allowed_tools"`
}
```

### 7.4 Runtime Root (resolved at startup)

```go
type resolvedRoot struct {
    Name         string
    RealPath     string   // Absolute, symlink-resolved path
    AllowedTools map[string]bool // Fast lookup set ("*" expands to all tools)
}
```

## 8. Documentation Requirements

All documentation listed below MUST be created and maintained as part of this project.

### 8.1 README.md

- Update the project README.md to include the new `mcp-filesystem` server in the project overview
- Add build, run, and configuration instructions for `mcp-filesystem`
- Include a quick-start example with a sample config

### 8.2 CLAUDE.md & .agent_docs/

- Update `CLAUDE.md` to add `mcp-filesystem` to the project structure section
- Add `mcp-filesystem` tool table (similar to the existing MCP Tools section)
- Update the `cmd/` listing
- Add a new `.agent_docs/mcp-filesystem.md` with detailed tool reference and security model documentation

### 8.3 docs/*

- Update `docs/overview.md` with `mcp-filesystem` in the features list
- Update `docs/architecture.md` with the new component and its security model
- Update `docs/functionalities.md` with the full tool reference
- Update `docs/deployment.md` with Docker Compose integration for `mcp-filesystem`

## 9. End-to-End Test Suite

All tests MUST be implemented in the `tests/` directory or as Go E2E tests following the existing pattern (`//go:build e2e`). Each feature MUST have tests covering happy paths, failure paths, edge cases, and error recovery.

### 9.1 Test Summary

| Test ID | Category | Scenario | Priority |
|---------|----------|----------|----------|
| E2E-001 | Core Journey | Read, modify, verify file workflow | Critical |
| E2E-002 | Core Journey | Multi-root discovery and cross-root copy | Critical |
| E2E-003 | Core Journey | Search codebase and patch file | Critical |
| E2E-004 | Feature | list_folder — happy path | Critical |
| E2E-005 | Feature | list_folder — empty directory | Medium |
| E2E-006 | Feature | list_folder — path is a file | High |
| E2E-007 | Feature | read_file — full read under threshold | Critical |
| E2E-008 | Feature | read_file — full read exceeds threshold | Critical |
| E2E-009 | Feature | read_file — byte-based partial read | High |
| E2E-010 | Feature | read_file — line-based partial read | High |
| E2E-011 | Feature | read_file — mixed byte+line parameters rejected | High |
| E2E-012 | Feature | read_file — offset beyond file end | Medium |
| E2E-013 | Feature | read_file — binary file detection | Medium |
| E2E-014 | Feature | write_file — overwrite mode | Critical |
| E2E-015 | Feature | write_file — append mode | High |
| E2E-016 | Feature | write_file — create_only mode, file absent | High |
| E2E-017 | Feature | write_file — create_only mode, file exists | High |
| E2E-018 | Feature | write_file — auto-create parent directories | High |
| E2E-019 | Feature | remove_file — happy path | Critical |
| E2E-020 | Feature | remove_file — file not found | High |
| E2E-021 | Feature | remove_file — target is directory | High |
| E2E-022 | Feature | patch_file — apply valid unified diff | Critical |
| E2E-023 | Feature | patch_file — hunk mismatch fails atomically | Critical |
| E2E-024 | Feature | patch_file — patch creates new file | High |
| E2E-025 | Feature | create_folder — happy path with nested parents | High |
| E2E-026 | Feature | create_folder — idempotent on existing directory | Medium |
| E2E-027 | Feature | create_folder — conflict with existing file | High |
| E2E-028 | Feature | remove_folder — recursive delete | Critical |
| E2E-029 | Feature | remove_folder — refuse root directory deletion | Critical |
| E2E-030 | Feature | remove_folder — target not found | High |
| E2E-031 | Feature | remove_folder — target is a file | High |
| E2E-032 | Feature | stat_file — file metadata | High |
| E2E-033 | Feature | stat_file — directory metadata | Medium |
| E2E-034 | Feature | stat_file — symlink metadata | Medium |
| E2E-035 | Feature | hash_file — sha256 | High |
| E2E-036 | Feature | hash_file — md5 and sha1 | Medium |
| E2E-037 | Feature | hash_file — unsupported algorithm | High |
| E2E-038 | Feature | hash_file — target is directory | Medium |
| E2E-039 | Feature | permissions_file — file permissions | High |
| E2E-040 | Feature | permissions_file — directory permissions | Medium |
| E2E-041 | Feature | copy — same root | High |
| E2E-042 | Feature | copy — cross-root | Critical |
| E2E-043 | Feature | copy — directory recursive | High |
| E2E-044 | Feature | copy — source not found | High |
| E2E-045 | Feature | move — same root (rename) | High |
| E2E-046 | Feature | move — cross-root | Critical |
| E2E-047 | Feature | move — source not found | High |
| E2E-048 | Feature | grep — regex match with context lines | Critical |
| E2E-049 | Feature | grep — case insensitive | High |
| E2E-050 | Feature | grep — file type filter | High |
| E2E-051 | Feature | grep — no matches | Medium |
| E2E-052 | Feature | grep — invalid regex | High |
| E2E-053 | Feature | grep — max results truncation | High |
| E2E-054 | Feature | grep — binary file skipped | Medium |
| E2E-055 | Feature | glob — glob pattern match | Critical |
| E2E-056 | Feature | glob — regex pattern match | High |
| E2E-057 | Feature | glob — doublestar recursive | High |
| E2E-058 | Feature | glob — type filter (files only) | Medium |
| E2E-059 | Feature | glob — no matches | Medium |
| E2E-060 | Feature | glob — both pattern and regex rejected | High |
| E2E-061 | Feature | list_roots — returns configured roots | Critical |
| E2E-062 | Feature | list_roots — does not expose host paths | High |
| E2E-063 | Security | Path traversal via .. rejected | Critical |
| E2E-064 | Security | Symlink escape to outside root rejected | Critical |
| E2E-065 | Security | Symlink within root followed successfully | High |
| E2E-066 | Security | Tool not in allowlist rejected | Critical |
| E2E-067 | Security | Cross-root copy denied by source allowlist | Critical |
| E2E-068 | Security | Cross-root copy denied by dest allowlist | Critical |
| E2E-069 | Security | remove_folder with symlink to outside root | Critical |
| E2E-070 | Security | Null bytes in path rejected | High |
| E2E-071 | Security | Double-encoded path traversal rejected | High |
| E2E-072 | Error | Invalid root name | Critical |
| E2E-073 | Error | Missing required parameters | High |
| E2E-074 | Error | Invalid write mode | High |
| E2E-075 | Error | Invalid hash algorithm | High |
| E2E-076 | Error | Invalid glob/regex syntax | High |
| E2E-077 | Performance | Large directory listing (1000+ entries) | Medium |
| E2E-078 | Performance | Hash of large file (streaming, not OOM) | Medium |
| E2E-079 | Performance | Grep timeout returns partial results | High |
| E2E-080 | Config | Server starts with valid config | Critical |
| E2E-081 | Config | Server fails on duplicate root names | High |
| E2E-082 | Config | Server fails on non-existent root path | High |
| E2E-083 | Config | Server fails on unknown tool in allowlist | High |
| E2E-084 | Config | Health endpoint returns 200 | High |

### 9.2 Test Specifications

#### E2E-001: Read, modify, verify file workflow

- **Category:** Core Journey
- **Scenario:** US-001, US-003, US-004
- **Preconditions:** Server running with a `workspace` root (all tools allowed), a file `hello.txt` exists with known content
- **Steps:**
  - Given the server is running with root `workspace` containing `hello.txt` with content "Hello World"
  - When agent calls `read_file` with root=workspace, path=hello.txt
  - Then the response contains "Hello World" and size metadata
  - When agent calls `patch_file` with a unified diff that changes "World" to "Agent"
  - Then the response confirms 1 hunk applied
  - When agent calls `read_file` again
  - Then the response contains "Hello Agent"
  - When agent calls `hash_file` with algorithm=sha256
  - Then the response contains the correct SHA-256 hash of "Hello Agent\n"
- **Priority:** Critical

#### E2E-002: Multi-root discovery and cross-root copy

- **Category:** Core Journey
- **Scenario:** US-006, US-009
- **Preconditions:** Server running with roots `source` (all tools) and `dest` (all tools), a file exists in `source`
- **Steps:**
  - Given the server is running with roots `source` and `dest`
  - When agent calls `list_roots`
  - Then the response lists both roots with their allowed tools and no host paths
  - When agent calls `write_file` with root=source, path=data.txt, content="important data"
  - Then the file is created successfully
  - When agent calls `copy` with source_root=source, source_path=data.txt, dest_root=dest, dest_path=data.txt
  - Then the copy succeeds
  - When agent calls `read_file` with root=dest, path=data.txt
  - Then the response contains "important data"
- **Priority:** Critical

#### E2E-003: Search codebase and patch file

- **Category:** Core Journey
- **Scenario:** US-005, US-004
- **Preconditions:** Server running with a `workspace` root containing multiple `.go` files with TODO comments
- **Steps:**
  - Given the server is running with root `workspace` containing Go source files
  - When agent calls `grep` with root=workspace, pattern="TODO", glob_filter="*.go", context_lines=1
  - Then the response contains matches with file paths, line numbers, and context
  - When agent calls `glob` with root=workspace, pattern="**/*.go"
  - Then the response lists all `.go` files recursively
  - When agent calls `patch_file` on one of the matched files with a diff that resolves the TODO
  - Then the patch is applied successfully
  - When agent calls `grep` again with the same pattern
  - Then the match count is reduced by the resolved TODOs
- **Priority:** Critical

#### E2E-004: list_folder — happy path

- **Category:** Feature
- **Scenario:** US-001
- **Preconditions:** Root `workspace` with known directory structure
- **Steps:**
  - Given root `workspace` contains files `a.txt`, `b.txt` and directory `sub/`
  - When agent calls `list_folder` with root=workspace, path="."
  - Then the response contains 3 entries sorted alphabetically: `a.txt` (file), `b.txt` (file), `sub` (directory)
  - And each entry has `name`, `type`, `size`, `modified_at` fields
- **Priority:** Critical

#### E2E-005: list_folder — empty directory

- **Category:** Feature
- **Scenario:** US-001 edge case
- **Preconditions:** Root `workspace` with an empty subdirectory `empty/`
- **Steps:**
  - Given root `workspace` contains an empty directory `empty/`
  - When agent calls `list_folder` with root=workspace, path="empty"
  - Then the response contains 0 entries and count=0
- **Priority:** Medium

#### E2E-006: list_folder — path is a file

- **Category:** Feature
- **Scenario:** US-001 failure
- **Preconditions:** Root `workspace` with a file `data.txt`
- **Steps:**
  - Given root `workspace` contains file `data.txt`
  - When agent calls `list_folder` with root=workspace, path="data.txt"
  - Then the response is an error indicating the path is not a directory
- **Priority:** High

#### E2E-007: read_file — full read under threshold

- **Category:** Feature
- **Scenario:** US-001
- **Preconditions:** Root `workspace` with a small file (under 1MB)
- **Steps:**
  - Given root `workspace` contains `small.txt` (100 bytes)
  - When agent calls `read_file` with root=workspace, path="small.txt" (no offset/limit)
  - Then the response contains the full file content and size=100
- **Priority:** Critical

#### E2E-008: read_file — full read exceeds threshold

- **Category:** Feature
- **Scenario:** US-001 failure
- **Preconditions:** Root `workspace` with a file larger than `max_full_read_size` (configure threshold low for test, e.g., 100 bytes)
- **Steps:**
  - Given `max_full_read_size` is configured to 100 bytes
  - And root `workspace` contains `large.txt` (500 bytes)
  - When agent calls `read_file` with root=workspace, path="large.txt" (no offset/limit)
  - Then the response is an error containing the file size (500) and the threshold (100)
- **Priority:** Critical

#### E2E-009: read_file — byte-based partial read

- **Category:** Feature
- **Scenario:** US-002
- **Preconditions:** Root `workspace` with a known file
- **Steps:**
  - Given root `workspace` contains `data.bin` with known content (256 bytes)
  - When agent calls `read_file` with root=workspace, path="data.bin", offset_bytes=10, limit_bytes=20
  - Then the response contains exactly bytes 10-29 of the file
- **Priority:** High

#### E2E-010: read_file — line-based partial read

- **Category:** Feature
- **Scenario:** US-002
- **Preconditions:** Root `workspace` with a multi-line file
- **Steps:**
  - Given root `workspace` contains `lines.txt` with 100 lines ("line 1" through "line 100")
  - When agent calls `read_file` with root=workspace, path="lines.txt", offset_lines=50, limit_lines=5
  - Then the response contains lines 50-54 ("line 50" through "line 54")
- **Priority:** High

#### E2E-011: read_file — mixed byte+line parameters rejected

- **Category:** Feature
- **Scenario:** FR-005 validation
- **Preconditions:** Root `workspace` with any file
- **Steps:**
  - Given root `workspace` contains `file.txt`
  - When agent calls `read_file` with root=workspace, path="file.txt", offset_bytes=0, offset_lines=1
  - Then the response is an error indicating byte and line parameters are mutually exclusive
- **Priority:** High

#### E2E-012: read_file — offset beyond file end

- **Category:** Feature
- **Scenario:** US-002 edge case
- **Preconditions:** Root `workspace` with a small file
- **Steps:**
  - Given root `workspace` contains `short.txt` with 5 lines
  - When agent calls `read_file` with root=workspace, path="short.txt", offset_lines=100, limit_lines=10
  - Then the response contains empty content with lines_total=5
- **Priority:** Medium

#### E2E-013: read_file — binary file detection

- **Category:** Feature
- **Scenario:** FR-005 edge case
- **Preconditions:** Root `workspace` with a binary file containing null bytes
- **Steps:**
  - Given root `workspace` contains `image.bin` with null bytes in the first 8KB
  - When agent calls `read_file` with root=workspace, path="image.bin", offset_bytes=0, limit_bytes=100
  - Then the response includes `binary: true` flag
- **Priority:** Medium

#### E2E-014: write_file — overwrite mode

- **Category:** Feature
- **Scenario:** US-003
- **Preconditions:** Root `workspace` with an existing file
- **Steps:**
  - Given root `workspace` contains `existing.txt` with content "old content"
  - When agent calls `write_file` with root=workspace, path="existing.txt", content="new content", mode="overwrite"
  - Then the response confirms success with size of "new content"
  - When agent calls `read_file` on the same path
  - Then the content is "new content" (old content is gone)
- **Priority:** Critical

#### E2E-015: write_file — append mode

- **Category:** Feature
- **Scenario:** FR-006
- **Preconditions:** Root `workspace` with an existing file
- **Steps:**
  - Given root `workspace` contains `log.txt` with content "line1\n"
  - When agent calls `write_file` with root=workspace, path="log.txt", content="line2\n", mode="append"
  - Then the response confirms success
  - When agent calls `read_file` on the same path
  - Then the content is "line1\nline2\n"
- **Priority:** High

#### E2E-016: write_file — create_only mode, file absent

- **Category:** Feature
- **Scenario:** US-003
- **Preconditions:** Root `workspace` without the target file
- **Steps:**
  - Given root `workspace` does not contain `new.txt`
  - When agent calls `write_file` with root=workspace, path="new.txt", content="created", mode="create_only"
  - Then the response confirms success
  - When agent calls `read_file` on the same path
  - Then the content is "created"
- **Priority:** High

#### E2E-017: write_file — create_only mode, file exists

- **Category:** Feature
- **Scenario:** US-003 failure
- **Preconditions:** Root `workspace` with the target file already existing
- **Steps:**
  - Given root `workspace` contains `existing.txt`
  - When agent calls `write_file` with root=workspace, path="existing.txt", content="nope", mode="create_only"
  - Then the response is an error indicating the file already exists
  - When agent calls `read_file` on the same path
  - Then the content is unchanged
- **Priority:** High

#### E2E-018: write_file — auto-create parent directories

- **Category:** Feature
- **Scenario:** US-003
- **Preconditions:** Root `workspace` without the parent directory
- **Steps:**
  - Given root `workspace` does not contain directory `deep/nested/dir/`
  - When agent calls `write_file` with root=workspace, path="deep/nested/dir/file.txt", content="deep"
  - Then the response confirms success
  - When agent calls `read_file` on the same path
  - Then the content is "deep"
- **Priority:** High

#### E2E-019: remove_file — happy path

- **Category:** Feature
- **Scenario:** FR-007
- **Preconditions:** Root `workspace` with a file to delete
- **Steps:**
  - Given root `workspace` contains `to_delete.txt`
  - When agent calls `remove_file` with root=workspace, path="to_delete.txt"
  - Then the response confirms removal
  - When agent calls `stat_file` on the same path
  - Then the response is a "file not found" error
- **Priority:** Critical

#### E2E-020: remove_file — file not found

- **Category:** Feature
- **Scenario:** FR-007 failure
- **Preconditions:** Root `workspace` without the target file
- **Steps:**
  - Given root `workspace` does not contain `ghost.txt`
  - When agent calls `remove_file` with root=workspace, path="ghost.txt"
  - Then the response is an error indicating file not found
- **Priority:** High

#### E2E-021: remove_file — target is directory

- **Category:** Feature
- **Scenario:** FR-007 failure
- **Preconditions:** Root `workspace` with a directory
- **Steps:**
  - Given root `workspace` contains directory `mydir/`
  - When agent calls `remove_file` with root=workspace, path="mydir"
  - Then the response is an error indicating the path is a directory
- **Priority:** High

#### E2E-022: patch_file — apply valid unified diff

- **Category:** Feature
- **Scenario:** US-004
- **Preconditions:** Root `workspace` with a known file
- **Steps:**
  - Given root `workspace` contains `code.go` with known content
  - When agent calls `patch_file` with a valid unified diff that modifies one function
  - Then the response confirms the number of hunks applied
  - When agent calls `read_file` on the same path
  - Then the content reflects the applied changes
- **Priority:** Critical

#### E2E-023: patch_file — hunk mismatch fails atomically

- **Category:** Feature
- **Scenario:** US-004 failure
- **Preconditions:** Root `workspace` with a file whose content doesn't match the diff context
- **Steps:**
  - Given root `workspace` contains `code.go` with content "line A\nline B\nline C\n"
  - When agent calls `patch_file` with a diff that expects "line X" at line 2
  - Then the response is an error indicating hunk failure
  - When agent calls `read_file` on the same path
  - Then the content is unchanged ("line A\nline B\nline C\n")
- **Priority:** Critical

#### E2E-024: patch_file — patch creates new file

- **Category:** Feature
- **Scenario:** US-004 edge case
- **Preconditions:** Root `workspace` without the target file
- **Steps:**
  - Given root `workspace` does not contain `new_file.txt`
  - When agent calls `patch_file` with a diff that adds content to a new file
  - Then the response confirms success
  - When agent calls `read_file` on the path
  - Then the content matches the diff additions
- **Priority:** High

#### E2E-025: create_folder — happy path with nested parents

- **Category:** Feature
- **Scenario:** FR-009
- **Preconditions:** Root `workspace` without the nested directories
- **Steps:**
  - Given root `workspace` does not contain `a/b/c/`
  - When agent calls `create_folder` with root=workspace, path="a/b/c"
  - Then the response confirms creation
  - When agent calls `list_folder` with root=workspace, path="a/b"
  - Then the listing includes directory `c`
- **Priority:** High

#### E2E-026: create_folder — idempotent on existing directory

- **Category:** Feature
- **Scenario:** FR-009 edge case
- **Preconditions:** Root `workspace` with the directory already existing
- **Steps:**
  - Given root `workspace` contains directory `existing_dir/`
  - When agent calls `create_folder` with root=workspace, path="existing_dir"
  - Then the response confirms success (no error)
- **Priority:** Medium

#### E2E-027: create_folder — conflict with existing file

- **Category:** Feature
- **Scenario:** FR-009 failure
- **Preconditions:** Root `workspace` with a file at the target path
- **Steps:**
  - Given root `workspace` contains file `conflict` (not a directory)
  - When agent calls `create_folder` with root=workspace, path="conflict"
  - Then the response is an error indicating path exists as a file
- **Priority:** High

#### E2E-028: remove_folder — recursive delete

- **Category:** Feature
- **Scenario:** US-007
- **Preconditions:** Root `workspace` with a non-empty directory tree
- **Steps:**
  - Given root `workspace` contains `dir/` with files and subdirectories inside
  - When agent calls `remove_folder` with root=workspace, path="dir"
  - Then the response confirms removal
  - When agent calls `stat_file` on "dir"
  - Then the response is a "not found" error
- **Priority:** Critical

#### E2E-029: remove_folder — refuse root directory deletion

- **Category:** Feature
- **Scenario:** FR-010 safety
- **Preconditions:** Root `workspace` configured
- **Steps:**
  - Given root `workspace` is configured
  - When agent calls `remove_folder` with root=workspace, path="" (or "." or "/")
  - Then the response is an error "cannot remove root directory"
- **Priority:** Critical

#### E2E-030: remove_folder — target not found

- **Category:** Feature
- **Scenario:** FR-010 failure
- **Steps:**
  - Given root `workspace` does not contain `nonexistent/`
  - When agent calls `remove_folder` with root=workspace, path="nonexistent"
  - Then the response is an error indicating directory not found
- **Priority:** High

#### E2E-031: remove_folder — target is a file

- **Category:** Feature
- **Scenario:** FR-010 failure
- **Steps:**
  - Given root `workspace` contains file `not_a_dir.txt`
  - When agent calls `remove_folder` with root=workspace, path="not_a_dir.txt"
  - Then the response is an error indicating path is a file, not a directory
- **Priority:** High

#### E2E-032: stat_file — file metadata

- **Category:** Feature
- **Scenario:** US-008
- **Steps:**
  - Given root `workspace` contains `data.json` (known size, known modification time)
  - When agent calls `stat_file` with root=workspace, path="data.json"
  - Then the response includes name, size, is_directory=false, modified_at as ISO 8601
- **Priority:** High

#### E2E-033: stat_file — directory metadata

- **Category:** Feature
- **Scenario:** FR-011 variant
- **Steps:**
  - Given root `workspace` contains directory `subdir/`
  - When agent calls `stat_file` with root=workspace, path="subdir"
  - Then the response includes is_directory=true
- **Priority:** Medium

#### E2E-034: stat_file — symlink metadata

- **Category:** Feature
- **Scenario:** FR-011 variant
- **Steps:**
  - Given root `workspace` contains a symlink `link` pointing to `target.txt` (within root)
  - When agent calls `stat_file` with root=workspace, path="link"
  - Then the response includes is_symlink=true and the target's metadata
- **Priority:** Medium

#### E2E-035: hash_file — sha256

- **Category:** Feature
- **Scenario:** US-008
- **Steps:**
  - Given root `workspace` contains `known.txt` with content "test content\n"
  - When agent calls `hash_file` with root=workspace, path="known.txt", algorithm="sha256"
  - Then the response contains the pre-computed SHA-256 hash of "test content\n"
- **Priority:** High

#### E2E-036: hash_file — md5 and sha1

- **Category:** Feature
- **Scenario:** FR-012
- **Steps:**
  - Given root `workspace` contains `known.txt` with known content
  - When agent calls `hash_file` with algorithm="md5"
  - Then the response contains the correct MD5 hash
  - When agent calls `hash_file` with algorithm="sha1"
  - Then the response contains the correct SHA-1 hash
- **Priority:** Medium

#### E2E-037: hash_file — unsupported algorithm

- **Category:** Feature
- **Scenario:** US-008 failure
- **Steps:**
  - Given root `workspace` contains any file
  - When agent calls `hash_file` with algorithm="md4"
  - Then the response is an error listing supported algorithms: md5, sha1, sha256
- **Priority:** High

#### E2E-038: hash_file — target is directory

- **Category:** Feature
- **Scenario:** FR-012 failure
- **Steps:**
  - Given root `workspace` contains directory `subdir/`
  - When agent calls `hash_file` with root=workspace, path="subdir", algorithm="sha256"
  - Then the response is an error indicating cannot hash a directory
- **Priority:** Medium

#### E2E-039: permissions_file — file permissions

- **Category:** Feature
- **Scenario:** FR-013
- **Steps:**
  - Given root `workspace` contains `script.sh` with mode 0755
  - When agent calls `permissions_file` with root=workspace, path="script.sh"
  - Then the response includes mode="0755", mode_string="-rwxr-xr-x", owner and group names
- **Priority:** High

#### E2E-040: permissions_file — directory permissions

- **Category:** Feature
- **Scenario:** FR-013
- **Steps:**
  - Given root `workspace` contains directory `subdir/` with mode 0755
  - When agent calls `permissions_file` with root=workspace, path="subdir"
  - Then the response includes mode and mode_string with directory flag (d)
- **Priority:** Medium

#### E2E-041: copy — same root

- **Category:** Feature
- **Scenario:** FR-014
- **Steps:**
  - Given root `workspace` contains `original.txt` with known content
  - When agent calls `copy` with source_root=workspace, source_path="original.txt", dest_root=workspace, dest_path="duplicate.txt"
  - Then the copy succeeds
  - When agent calls `read_file` on both paths
  - Then both files have identical content
- **Priority:** High

#### E2E-042: copy — cross-root

- **Category:** Feature
- **Scenario:** US-006
- **Steps:**
  - Given roots `source` and `dest`, `source` contains `file.txt`
  - When agent calls `copy` with source_root=source, dest_root=dest
  - Then the file exists in both roots with identical content
- **Priority:** Critical

#### E2E-043: copy — directory recursive

- **Category:** Feature
- **Scenario:** FR-014
- **Steps:**
  - Given root `workspace` contains directory `project/` with nested files
  - When agent calls `copy` with source_path="project", dest_path="project-backup"
  - Then the entire directory tree is copied
  - When agent calls `glob` on "project-backup/**/*"
  - Then all files from the original are present
- **Priority:** High

#### E2E-044: copy — source not found

- **Category:** Feature
- **Scenario:** FR-014 failure
- **Steps:**
  - Given root `workspace` does not contain `missing.txt`
  - When agent calls `copy` with source_path="missing.txt"
  - Then the response is an error indicating source not found
- **Priority:** High

#### E2E-045: move — same root (rename)

- **Category:** Feature
- **Scenario:** FR-015
- **Steps:**
  - Given root `workspace` contains `old_name.txt` with known content
  - When agent calls `move` with source_path="old_name.txt", dest_path="new_name.txt" (same root)
  - Then the move succeeds
  - When agent calls `stat_file` on "old_name.txt"
  - Then it returns not found
  - When agent calls `read_file` on "new_name.txt"
  - Then the content matches the original
- **Priority:** High

#### E2E-046: move — cross-root

- **Category:** Feature
- **Scenario:** FR-015
- **Steps:**
  - Given roots `source` and `dest`, `source` contains `file.txt`
  - When agent calls `move` with source_root=source, dest_root=dest
  - Then the file exists in `dest` but not in `source`
- **Priority:** Critical

#### E2E-047: move — source not found

- **Category:** Feature
- **Scenario:** FR-015 failure
- **Steps:**
  - Given root `workspace` does not contain `missing.txt`
  - When agent calls `move` with source_path="missing.txt"
  - Then the response is an error indicating source not found
- **Priority:** High

#### E2E-048: grep — regex match with context lines

- **Category:** Feature
- **Scenario:** US-005
- **Steps:**
  - Given root `workspace` contains `code.go` with `// TODO: fix this` at line 10
  - When agent calls `grep` with pattern="TODO", context_lines=2
  - Then the response includes the match at line 10 with 2 lines before and after
- **Priority:** Critical

#### E2E-049: grep — case insensitive

- **Category:** Feature
- **Scenario:** FR-016
- **Steps:**
  - Given root `workspace` contains files with "Error", "error", "ERROR"
  - When agent calls `grep` with pattern="error", case_insensitive=true
  - Then all three variants are matched
- **Priority:** High

#### E2E-050: grep — file type filter

- **Category:** Feature
- **Scenario:** FR-016
- **Steps:**
  - Given root `workspace` contains `file.go` and `file.py` both containing "TODO"
  - When agent calls `grep` with pattern="TODO", glob_filter="*.go"
  - Then only `file.go` matches are returned
- **Priority:** High

#### E2E-051: grep — no matches

- **Category:** Feature
- **Scenario:** FR-016 edge case
- **Steps:**
  - Given root `workspace` contains files without the search pattern
  - When agent calls `grep` with pattern="ZZZZUNIQUEZZZZZ"
  - Then the response has total_matches=0 and empty matches array
- **Priority:** Medium

#### E2E-052: grep — invalid regex

- **Category:** Feature
- **Scenario:** FR-016 failure
- **Steps:**
  - Given root `workspace` configured
  - When agent calls `grep` with pattern="[invalid"
  - Then the response is an error with the regex parse error
- **Priority:** High

#### E2E-053: grep — max results truncation

- **Category:** Feature
- **Scenario:** FR-016 safeguard
- **Steps:**
  - Given root `workspace` contains 200+ files each containing "match"
  - When agent calls `grep` with pattern="match", max_results=5
  - Then the response has exactly 5 matches and truncated=true
- **Priority:** High

#### E2E-054: grep — binary file skipped

- **Category:** Feature
- **Scenario:** FR-016 edge case
- **Steps:**
  - Given root `workspace` contains a binary file with null bytes and a text file, both containing pattern bytes
  - When agent calls `grep` with a pattern
  - Then only the text file appears in results
- **Priority:** Medium

#### E2E-055: glob — glob pattern match

- **Category:** Feature
- **Scenario:** FR-017
- **Steps:**
  - Given root `workspace` contains `a.go`, `b.go`, `c.txt`
  - When agent calls `glob` with pattern="*.go"
  - Then the response lists `a.go` and `b.go` only
- **Priority:** Critical

#### E2E-056: glob — regex pattern match

- **Category:** Feature
- **Scenario:** FR-017
- **Steps:**
  - Given root `workspace` contains `test_1.go`, `test_2.go`, `main.go`
  - When agent calls `glob` with regex="test_\\d+\\.go"
  - Then the response lists `test_1.go` and `test_2.go`
- **Priority:** High

#### E2E-057: glob — doublestar recursive

- **Category:** Feature
- **Scenario:** FR-017
- **Steps:**
  - Given root `workspace` contains `src/a.go`, `src/pkg/b.go`, `src/pkg/sub/c.go`
  - When agent calls `glob` with pattern="**/*.go"
  - Then the response lists all three `.go` files
- **Priority:** High

#### E2E-058: glob — type filter (files only)

- **Category:** Feature
- **Scenario:** FR-017
- **Steps:**
  - Given root `workspace` contains files and directories
  - When agent calls `glob` with pattern="*", type_filter="file"
  - Then only files are returned (no directories)
- **Priority:** Medium

#### E2E-059: glob — no matches

- **Category:** Feature
- **Scenario:** FR-017 edge case
- **Steps:**
  - Given root `workspace` contains no `.xyz` files
  - When agent calls `glob` with pattern="*.xyz"
  - Then the response has total_matches=0
- **Priority:** Medium

#### E2E-060: glob — both pattern and regex rejected

- **Category:** Feature
- **Scenario:** FR-017 validation
- **Steps:**
  - Given root `workspace` configured
  - When agent calls `glob` with pattern="*.go" AND regex=".*\\.go"
  - Then the response is an error indicating exactly one of pattern or regex must be provided
- **Priority:** High

#### E2E-061: list_roots — returns configured roots

- **Category:** Feature
- **Scenario:** US-009
- **Steps:**
  - Given server is running with roots `workspace`, `config`, `logs`
  - When agent calls `list_roots`
  - Then the response lists all three roots with their names and allowed_tools
- **Priority:** Critical

#### E2E-062: list_roots — does not expose host paths

- **Category:** Feature
- **Scenario:** FR-003 security
- **Steps:**
  - Given server is running with roots configured at specific host paths
  - When agent calls `list_roots`
  - Then the response does NOT contain any host filesystem paths (no `/data/`, `/etc/`, etc.)
- **Priority:** High

#### E2E-063: Path traversal via .. rejected

- **Category:** Security
- **Scenario:** US-011
- **Steps:**
  - Given root `workspace` configured at a specific path
  - When agent calls `read_file` with path="../../etc/passwd"
  - Then the response is a security error about path resolving outside root boundary
- **Priority:** Critical

#### E2E-064: Symlink escape to outside root rejected

- **Category:** Security
- **Scenario:** US-011
- **Preconditions:** A symlink inside root pointing to a path outside root
- **Steps:**
  - Given root `workspace` contains symlink `escape` pointing to `/tmp` (outside root)
  - When agent calls `list_folder` with path="escape"
  - Then the response is a security error about path resolving outside root boundary
- **Priority:** Critical

#### E2E-065: Symlink within root followed successfully

- **Category:** Security
- **Scenario:** FR-001
- **Steps:**
  - Given root `workspace` contains symlink `link.txt` pointing to `real.txt` (both within root)
  - When agent calls `read_file` with path="link.txt"
  - Then the response contains the content of `real.txt` (symlink was followed)
- **Priority:** High

#### E2E-066: Tool not in allowlist rejected

- **Category:** Security
- **Scenario:** US-010
- **Steps:**
  - Given root `readonly` configured with allowed_tools=["list_folder", "read_file"]
  - When agent calls `write_file` with root=readonly
  - Then the response is an error "tool write_file not allowed on root readonly"
- **Priority:** Critical

#### E2E-067: Cross-root copy denied by source allowlist

- **Category:** Security
- **Scenario:** FR-002
- **Steps:**
  - Given root `restricted` with allowed_tools=["list_folder"] (no `copy`)
  - And root `dest` with allowed_tools=["*"]
  - When agent calls `copy` with source_root=restricted, dest_root=dest
  - Then the response is an error about `copy` not allowed on root `restricted`
- **Priority:** Critical

#### E2E-068: Cross-root copy denied by dest allowlist

- **Category:** Security
- **Scenario:** FR-002
- **Steps:**
  - Given root `source` with allowed_tools=["*"]
  - And root `readonly` with allowed_tools=["list_folder", "read_file"] (no `copy`)
  - When agent calls `copy` with source_root=source, dest_root=readonly
  - Then the response is an error about `copy` not allowed on root `readonly`
- **Priority:** Critical

#### E2E-069: remove_folder with symlink to outside root

- **Category:** Security
- **Scenario:** FR-010 security
- **Steps:**
  - Given root `workspace` contains directory `dir/` with a symlink `dir/escape` pointing outside root
  - When agent calls `remove_folder` with path="dir"
  - Then the symlink itself is removed but the target outside root is NOT affected
  - And no error is thrown (the symlink entry is deleted, not its target)
- **Priority:** Critical

#### E2E-070: Null bytes in path rejected

- **Category:** Security
- **Scenario:** NFR-010
- **Steps:**
  - Given root `workspace` configured
  - When agent calls `read_file` with path containing a null byte (e.g., "file\x00.txt")
  - Then the response is a security error
- **Priority:** High

#### E2E-071: Double-encoded path traversal rejected

- **Category:** Security
- **Scenario:** NFR-010
- **Steps:**
  - Given root `workspace` configured
  - When agent calls `read_file` with path="%2e%2e%2fetc%2fpasswd"
  - Then the path is treated literally (as a filename containing percent characters) or rejected
  - And no file outside the root is accessed
- **Priority:** High

#### E2E-072: Invalid root name

- **Category:** Error
- **Scenario:** Error handling
- **Steps:**
  - Given server is running with roots `workspace` and `logs`
  - When agent calls any tool with root="nonexistent"
  - Then the response is an error "unknown root: nonexistent"
- **Priority:** Critical

#### E2E-073: Missing required parameters

- **Category:** Error
- **Scenario:** Error handling
- **Steps:**
  - Given server is running
  - When agent calls `read_file` without the `root` parameter
  - Then the response is an error indicating `root` is required
  - When agent calls `read_file` with root but without `path`
  - Then the response is an error indicating `path` is required
- **Priority:** High

#### E2E-074: Invalid write mode

- **Category:** Error
- **Scenario:** FR-006 validation
- **Steps:**
  - Given root `workspace` configured
  - When agent calls `write_file` with mode="truncate"
  - Then the response is an error listing valid modes: overwrite, append, create_only
- **Priority:** High

#### E2E-075: Invalid hash algorithm

- **Category:** Error
- **Scenario:** FR-012 validation
- **Steps:**
  - Given root `workspace` configured
  - When agent calls `hash_file` with algorithm="sha512"
  - Then the response is an error listing valid algorithms: md5, sha1, sha256
- **Priority:** High

#### E2E-076: Invalid glob/regex syntax

- **Category:** Error
- **Scenario:** FR-017 validation
- **Steps:**
  - Given root `workspace` configured
  - When agent calls `glob` with regex="[unclosed"
  - Then the response is an error with the regex parse error message
- **Priority:** High

#### E2E-077: Large directory listing (1000+ entries)

- **Category:** Performance
- **Scenario:** NFR-002
- **Preconditions:** Root `workspace` with a directory containing 1000+ files
- **Steps:**
  - Given root `workspace` contains directory `big/` with 1500 files
  - When agent calls `list_folder` with path="big"
  - Then the response lists all 1500 entries
  - And the response completes within 2 seconds
- **Priority:** Medium

#### E2E-078: Hash of large file (streaming, not OOM)

- **Category:** Performance
- **Scenario:** NFR-003
- **Steps:**
  - Given root `workspace` contains a 50MB file `large.bin`
  - When agent calls `hash_file` with algorithm="sha256"
  - Then the response contains the correct hash
  - And the server process memory does not spike by 50MB (streaming verification)
- **Priority:** Medium

#### E2E-079: Grep timeout returns partial results

- **Category:** Performance
- **Scenario:** NFR-004
- **Steps:**
  - Given root `workspace` contains a very large directory tree
  - When agent calls `grep` with a common pattern and timeout_seconds=1
  - Then the response has timed_out=true and contains partial matches collected before timeout
- **Priority:** High

#### E2E-080: Server starts with valid config

- **Category:** Config
- **Scenario:** FR-018
- **Steps:**
  - Given a valid YAML config file with roots pointing to existing directories
  - When the server is started with --config flag
  - Then the server starts successfully and the health endpoint returns 200
- **Priority:** Critical

#### E2E-081: Server fails on duplicate root names

- **Category:** Config
- **Scenario:** FR-018 validation
- **Steps:**
  - Given a YAML config with two roots both named "data"
  - When the server is started
  - Then the server exits with an error about duplicate root names
- **Priority:** High

#### E2E-082: Server fails on non-existent root path

- **Category:** Config
- **Scenario:** FR-018 validation
- **Steps:**
  - Given a YAML config with a root path that does not exist
  - When the server is started
  - Then the server exits with an error about the non-existent path
- **Priority:** High

#### E2E-083: Server fails on unknown tool in allowlist

- **Category:** Config
- **Scenario:** FR-018 validation
- **Steps:**
  - Given a YAML config with allowed_tools containing "nonexistent_tool"
  - When the server is started
  - Then the server exits with an error about the unknown tool name
- **Priority:** High

#### E2E-084: Health endpoint returns 200

- **Category:** Config
- **Scenario:** FR-019
- **Steps:**
  - Given the server is running
  - When a GET request is sent to /health
  - Then the response status is 200 and body is "ok"
- **Priority:** High

## 10. Open Questions & TBDs

- **OQ-001:** Should the `grep` timeout be configurable at the server level (YAML config) in addition to per-call? Currently only per-call is specified.
- **OQ-002:** Should `write_file` in overwrite mode use atomic write (write to temp file + rename) for all files, or only for files above a certain size? Atomic writes are safer but may have performance implications on some filesystems.
- **OQ-003:** For the unified diff parser, should we use an existing Go library (e.g., `sourcegraph/go-diff`) or implement a minimal parser? A library is more robust; a custom parser avoids a dependency.
- **OQ-004:** Should `copy` of a directory preserve symlinks as symlinks, or resolve them? Current spec follows symlinks if safe, but during recursive copy, preserving the symlink structure might be more correct.

## 11. Glossary

| Term | Definition |
|------|------------|
| **MCP** | Model Context Protocol — a protocol for LLM tool integration |
| **Streamable HTTP** | MCP transport over HTTP with streaming support (replaces legacy stdio) |
| **Root** | A named, sandboxed directory boundary that the MCP server can operate within |
| **Allowlist** | A per-root list of tool names that are permitted to operate on that root |
| **Chroot** | A Unix operation that changes the apparent root directory for a process; used here as a conceptual model for path confinement |
| **Realpath** | The absolute, symlink-resolved path to a file; used for security validation |
| **Unified diff** | A standard format for representing text file changes, as produced by `diff -u` or `git diff` |
| **destructiveHint** | An MCP tool annotation indicating whether the tool modifies state; set to `false` for all tools in this server |
| **Hunk** | A contiguous block of changes within a unified diff |
| **Doublestar** | Glob pattern `**` that matches any number of path segments recursively |
